<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zz_xiaoming's blog."><meta name="keywords" content="博客, 前端, js"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>宏任务、微任务以及Event-Loop | zz_xiaoming's blog.</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">宏任务、微任务以及Event-Loop</h1><a id="logo" href="/.">zz_xiaoming's blog.</a><p class="description">less talking, more working</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">宏任务、微任务以及Event-Loop</h1><div class="post-meta"><a href="/2018/09/05/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEvent-Loop/#comments" class="comment-count"></a><p><span class="date">Sep 05, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p><img src="/2018/09/05/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEvent-Loop/d1.jpg" alt="风车" title="风车"></p>
<hr>
<p>首先，JavaScript是一个单线程的脚本语言。</p>
<p>所以就是说在一行代码执行的过程中，必然不会存在同时执行的另一行代码，就像使用alert()以后进行疯狂console.log，如果没有关闭弹框，控制台是不会显示出一条log信息的。</p>
<p>亦或者有些代码执行了大量计算，比方说在前端暴力破解密码之类的鬼操作，这就会导致后续代码一直在等待，页面处于假死状态，因为前边的代码并没有执行完。</p>
<p>所以如果全部代码都是同步执行的，这会引发很严重的问题，比方说我们要从远端获取一些数据，难道要一直循环代码去判断是否拿到了返回结果么？就像去饭店点餐，肯定不能说点完了以后就去后厨催着人炒菜的，会被揍的。</p>
<p>于是就有了异步事件的概念，注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后通知我，然后我们就可以去做其他的事情了。</p>
<p>然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。</p>
<p>比如说打了个车，如果司机先到了，但是你手头还有点儿事情要处理，这时司机是不可能自己先开着车走的，一定要等到你处理完事情上了车才能走。</p>
<blockquote>
<h3 id="微任务与宏任务的区别"><a href="#微任务与宏任务的区别" class="headerlink" title="微任务与宏任务的区别"></a>微任务与宏任务的区别</h3></blockquote>
<p>这个就像去银行办业务一样，先要取号进行排号。<br>一般上边都会印着类似：“您的号码为XX，前边还有XX人。”之类的字样。</p>
<p>因为柜员同时职能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。</p>
<p>所以多个宏任务合在一起就可以认为说有一个任务队列在这，里边是当前银行中所有排号的客户。</p>
<p><strong>任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中，就像在银行中排号，如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号</strong></p>
<p>而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。</p>
<p>所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。</p>
<p>也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？</p>
<p>无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。</p>
<p>这就说明：<del>你大爷永远是你大爷</del></p>
<p><strong>在当前的微任务没有执行完成时，是不会执行下一个宏任务的。</strong></p>
<p>所以就有了那个经常在面试题、各种博客中的代码片段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>setTimeout就是作为宏任务来存在的，而Promise.then则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p>
<p><strong>所有会进入的异步都是指的事件回调中的那部分代码</strong></p>
<p>也就是说new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。</p>
<p>在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。<br>所以就得到了上述的输出结论<strong>1、2、3、4</strong>。</p>
<p>+部分表示同步执行的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">-  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">+&#125;)</span><br><span class="line"></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">+  resolve()</span><br><span class="line">+  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">+&#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">-  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">+&#125;)</span><br><span class="line"></span><br><span class="line">+<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>本来setTimeout已经先设置了定时器（相当于取号），然后在当前进程中又添加了一些Promise的处理（临时添加业务）。</p>
<p>所以进阶的，即便我们继续在Promise中实例化Promise，其输出依然会早于setTimeout的宏任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'before timeout'</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'also before timeout'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>当然了，实际情况下很少会有简单的这么调用Promise的，一般都会在里边有其他的异步操作，比如fetch、fs.readFile之类的操作。<br>而这些其实就相当于注册了一个宏任务，而非是微任务。</p>
<p>P.S. <em>在<a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener">Promise/A+</a>的规范中，Promise的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少Chrome是这么做的)，Promise应该是属于微任务阵营的</em></p>
<p>所以，明白哪些操作是宏任务、哪些是微任务就变得很关键，这是目前业界比较流行的说法：</p>
<p><strong>宏任务</strong></p>
<p><img src="/2018/09/05/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEvent-Loop/q1.png" alt="q1" title="q1"></p>
<p>有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤</p>
<p>requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行</p>
<p><img src="/2018/09/05/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEvent-Loop/q2.png" alt="q2" title="q2"></p>
<blockquote>
<h3 id="Event-Loop是个啥"><a href="#Event-Loop是个啥" class="headerlink" title="Event-Loop是个啥"></a>Event-Loop是个啥</h3></blockquote>
<p>上边一直在讨论 宏任务、微任务，各种任务的执行。</p>
<p>但是回到现实，JavaScript是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。</p>
<p>每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。<strong>（检查还有没有微任务需要处理）</strong><br>而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。<strong>（结束本次宏任务、检查还有没有宏任务需要处理）</strong></p>
<p>这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。(这是个非常简易的描述了，实际上会复杂很多)</p>
<p>而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> macroTaskList = [</span><br><span class="line">  [<span class="string">'task1'</span>],</span><br><span class="line">  [<span class="string">'task2'</span>, <span class="string">'task3'</span>],</span><br><span class="line">  [<span class="string">'task4'</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> macroIndex = <span class="number">0</span>; macroIndex &lt; macroTaskList.length; macroIndex++) &#123;</span><br><span class="line">  <span class="keyword">const</span> microTaskList = macroTaskList[macroIndex]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> microIndex = <span class="number">0</span>; microIndex &lt; microTaskList.length; microIndex++) &#123;</span><br><span class="line">    <span class="keyword">const</span> microTask = microTaskList[microIndex]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个微任务</span></span><br><span class="line">    <span class="keyword">if</span> (microIndex === <span class="number">1</span>) microTaskList.push(<span class="string">'special micro task'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="built_in">console</span>.log(microTask)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加一个宏任务</span></span><br><span class="line">  <span class="keyword">if</span> (macroIndex === <span class="number">2</span>) macroTaskList.push([<span class="string">'special macro task'</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt; task1</span></span><br><span class="line"><span class="comment">// &gt; task2</span></span><br><span class="line"><span class="comment">// &gt; task3</span></span><br><span class="line"><span class="comment">// &gt; special micro task</span></span><br><span class="line"><span class="comment">// &gt; task4</span></span><br><span class="line"><span class="comment">// &gt; special macro task</span></span><br></pre></td></tr></table></figure>

<p>之所以使用两个for循环来表示，是因为在循环内部可以很方便的进行push之类的操作（添加一些任务），从而使迭代的次数动态的增加。</p>
<p>以及还要明确的是，Event Loop只是负责告诉你该执行那些任务，或者说哪些回调被触发了，真正的逻辑还是在进程中执行的。</p>
<p><strong>在浏览器中的表现</strong></p>
<p>在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？</p>
<p>首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）</p>
<p>I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。</p>
<p>假设有这样的一些DOM结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#outer</span> &#123;</span></span><br><span class="line">    padding: 20px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#616161</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">  <span class="selector-id">#inner</span> &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#757575</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $inner = <span class="built_in">document</span>.querySelector(<span class="string">'#inner'</span>)</span><br><span class="line"><span class="keyword">const</span> $outer = <span class="built_in">document</span>.querySelector(<span class="string">'#outer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'click'</span>) <span class="comment">// 直接输出</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'promise'</span>)) <span class="comment">// 注册微任务</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)) <span class="comment">// 注册宏任务</span></span><br><span class="line"></span><br><span class="line">  requestAnimationFrame(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'animationFrame'</span>)) <span class="comment">// 注册宏任务</span></span><br><span class="line"></span><br><span class="line">  $outer.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random()) <span class="comment">// DOM属性修改，触发微任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observer'</span>)</span><br><span class="line">&#125;).observe($outer, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$inner.addEventListener(<span class="string">'click'</span>, handler)</span><br><span class="line">$outer.addEventListener(<span class="string">'click'</span>, handler)</span><br></pre></td></tr></table></figure>

<p>如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。</p>
<p>因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。</p>
<p>按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。</p>
<p>因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(一次在inner、一次在outer)，所以会优先执行冒泡的事件(早于其他的宏任务)，也就是说会重复上述的逻辑。</p>
<p>在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。</p>
<p>需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。</p>
<p><strong>一些小惊喜</strong></p>
<p>使用上述的示例代码，如果将手动点击DOM元素的触发方式变为$inner.click()，那么会得到不一样的结果。<br>在Chrome下的输出顺序大致是这样的：<br>click -&gt; click -&gt; promise -&gt; observer -&gt; promise -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。</p>
<p>与我们手动触发click的执行顺序不一样的原因是这样的，因为并不是用户通过点击元素实现的触发事件，而是类似dispatchEvent这样的方式，我个人觉得并不能算是一个有效的I/O，在执行了一次handler回调注册了微任务、注册了宏任务以后，实际上外边的$inner.click()并没有执行完。</p>
<p>所以在微任务执行之前，还要继续冒泡执行下一次事件，也就是说触发了第二次的handler。<br>所以输出了第二次click，等到这两次handler都执行完毕后才会去检查有没有微任务、有没有宏任务。</p>
<p>两点需要注意的：</p>
<ol>
<li>.click()的这种触发事件的方式个人认为是类似dispatchEvent，可以理解为同步执行的代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, _ =&gt; <span class="built_in">console</span>.log(<span class="string">'click'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.click()</span><br><span class="line"><span class="built_in">document</span>.body.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'click'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt; click</span></span><br><span class="line"><span class="comment">// &gt; click</span></span><br><span class="line"><span class="comment">// &gt; done</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>MutationObserver的监听不会说同时触发多次，多次修改只会有一次回调被触发。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'observer'</span>)</span><br><span class="line">  <span class="comment">// 如果在这输出DOM的data-random属性，必然是最后一次的值，不解释了</span></span><br><span class="line">&#125;).observe(<span class="built_in">document</span>.body, &#123;</span><br><span class="line">  attributes: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"><span class="built_in">document</span>.body.setAttribute(<span class="string">'data-random'</span>, <span class="built_in">Math</span>.random())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会输出一次 ovserver</span></span><br></pre></td></tr></table></figure>

<p>这就像去饭店点餐，服务员喊了三次，XX号的牛肉面，不代表她会给你三碗牛肉面。<br>上述观点参阅自<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight" target="_blank" rel="noopener">Tasks, microtasks, queues and schedules</a>，文中有动画版的讲解</p>
<p><strong>在Node中的表现</strong></p>
<p>Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" target="_blank" rel="noopener">Node官方文档</a>的地址。</p>
<p>就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。</p>
<p><strong>setImmediate与setTimeout的区别</strong></p>
<p>在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。</p>
<p>setTimeout则是通过计算一个延迟时间后进行执行。</p>
<p>但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。</p>
<p>因为如果主进程中先注册了两个任务，然后执行的代码耗时超过XXs，而这时定时器已经处于可执行回调的状态了。</p>
<p>所以会先执行定时器，而执行完定时器以后才是结束了一次Event Loop，这时才会执行setImmediate。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set<span class="constructor">Timeout(<span class="params">_</span> =&gt; <span class="params">console</span>.<span class="params">log</span>('<span class="params">setTimeout</span>')</span>)</span><br><span class="line">set<span class="constructor">Immediate(<span class="params">_</span> =&gt; <span class="params">console</span>.<span class="params">log</span>('<span class="params">setImmediate</span>')</span>)</span><br></pre></td></tr></table></figure>

<p>有兴趣的可以自己试验一下，执行多次真的会得到不同的结果。</p>
<p><img src="/2018/09/05/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E3%80%81%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8AEvent-Loop/q3.png" alt="q3" title="q3"></p>
<p>但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set<span class="constructor">Timeout(<span class="params">_</span> =&gt; <span class="params">console</span>.<span class="params">log</span>('<span class="params">setTimeout</span>')</span>)</span><br><span class="line">set<span class="constructor">Immediate(<span class="params">_</span> =&gt; <span class="params">console</span>.<span class="params">log</span>('<span class="params">setImmediate</span>')</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> countdown = <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(countdonn--) &#123; &#125; <span class="comment">// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`</span></span><br></pre></td></tr></table></figure>

<p>如果在另一个宏任务中，必然是setImmediate先执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(__dirname, _ =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'timeout'</span>))</span><br><span class="line">  setImmediate(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'immediate'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果</span></span><br></pre></td></tr></table></figure>

<p><strong>process.nextTick</strong></p>
<p>就像上边说的，这个可以认为是一个类似于Promise和MutationObserver的微任务实现，在代码执行的过程中可以随时插入nextTick，并且会保证在下一个宏任务开始之前所执行。</p>
<p>在使用方面的一个最常见的例子就是一些事件绑定类的操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lib</span> <span class="keyword">extends</span> <span class="title">require</span>(<span class="params">'events'</span>).<span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="symbol">'ini</span>t')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const lib = <span class="keyword">new</span> <span class="type">Lib</span>()</span><br><span class="line"></span><br><span class="line">lib.on(<span class="symbol">'ini</span>t', _ =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里将永远不会执行</span></span><br><span class="line">  console.log(<span class="symbol">'init</span>!')</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为上述的代码在实例化Lib对象时是同步执行的，在实例化完成以后就立马发送了init事件。<br>而这时在外层的主程序还没有开始执行到lib.on(‘init’)监听事件的这一步。<br>所以会导致发送事件时没有回调，回调注册后事件不会再次发送。</p>
<p>我们可以很轻松的使用process.nextTick来解决这个问题：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lib</span> <span class="keyword">extends</span> <span class="title">require</span>(<span class="params">'events'</span>).<span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line"></span><br><span class="line">    process.nextTick(_ =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.emit(<span class="symbol">'ini</span>t')</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同理使用其他的微任务</span></span><br><span class="line">    <span class="comment">// 比如Promise.resolve().then(_ =&gt; this.emit('init'))</span></span><br><span class="line">    <span class="comment">// 也可以实现相同的效果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会在主进程的代码执行完毕后，程序空闲时触发Event Loop流程查找有没有微任务，然后再发送init事件。</p>
<p>关于有些文章中提到的，循环调用process.nextTick会导致报警，后续的代码永远不会被执行，这是对的，参见上边使用的双重循环实现的loop即可，相当于在每次for循环执行中都对数组进行了push操作，这样循环永远也不会结束</p>
<p><strong>多提一嘴async/await函数</strong></p>
<p>因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于new Promise时传入的代码，await之后的所有代码都是在Promise.then中的回调</strong></p>
</div><div class="post-copyright"><blockquote><p>原文作者: 骑猪骑士</p><p>原文链接: <a href="http://zhaokunming.xyz/2018/09/05/宏任务、微任务以及Event-Loop/">http://zhaokunming.xyz/2018/09/05/宏任务、微任务以及Event-Loop/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/js/">js</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2018/11/22/%E3%80%8A%E4%BA%BA%E9%97%B4%E5%A4%B1%E6%A0%BC%E3%80%8B/" class="pre">随笔：《人间失格》</a><a href="/2018/06/20/redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/" class="next">redux状态管理框架</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'b9866c2ced487dfb61db',
  clientSecret: '802b6c3f8fe51c7e135315c617f51de05ecd97f1',
  repo: 'gitalk.github.io',
  owner: 'pretendtobehappy',
  admin: ['pretendtobehappy'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#微任务与宏任务的区别"><span class="toc-text">微任务与宏任务的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Event-Loop是个啥"><span class="toc-text">Event-Loop是个啥</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/11/%E6%96%B0%E5%A2%9E%E5%92%8C%E7%BC%96%E8%BE%91%E5%BC%B9%E7%AA%97%E9%97%AE%E9%A2%98/">新增和编辑弹窗问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/28/%E5%85%B3%E4%BA%8E%E6%96%B0%E5%86%A0%E7%8A%B6%E7%97%85%E6%AF%92%E7%9A%84%E8%B6%85%E9%95%BF%E5%81%87%E6%9C%9F/">关于新冠状病毒的超长假期</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%98%A5%E8%BF%90/">记一次春运</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/05/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3vue%E4%B8%AD%E7%9A%84nextTick/">简单理解vue中的nextTick</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/11/vue%E4%B8%ADslot%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8/">vue中slot插槽的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/29/el-table%E4%B8%8Eel-form%E5%90%8C%E7%94%A8%E5%8F%8A%E6%A0%A1%E9%AA%8C/">el-table与el-form同用及校验</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/el-form%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%BD%A6%E8%BF%9B%E5%85%A5%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E6%A1%86/">el-form实现回车进入下一个输入框</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/02/element-ui%E5%8F%AF%E9%80%89%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6/">elementUI中DateTimePicker日期时间选择器的范围限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/%E4%B8%8B%E6%8B%89%E5%A4%8D%E9%80%89%E6%A1%86/">下拉复选框</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/13/%E5%A4%9A%E4%B8%AA%E5%A4%8D%E9%80%89%E6%A1%86%E4%B8%AD%E7%9A%84%E8%81%94%E5%8A%A8/">多个复选框中的联动</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/axios/" style="font-size: 15px;">axios</a> <a href="/tags/vue/" style="font-size: 15px;">vue</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" style="font-size: 15px;">自适应</a> <a href="/tags/elementUI/" style="font-size: 15px;">elementUI</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 15px;">web性能优化</a> <a href="/tags/vuex%E8%AF%AD%E6%B3%95%E7%B3%96/" style="font-size: 15px;">vuex语法糖</a> <a href="/tags/vue%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/" style="font-size: 15px;">vue辅助函数</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/flux/" style="font-size: 15px;">flux</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 15px;">生活</a> <a href="/tags/start/" style="font-size: 15px;">start</a> <a href="/tags/redux/" style="font-size: 15px;">redux</a> <a href="/tags/withRouter/" style="font-size: 15px;">withRouter</a> <a href="/tags/title%E8%AE%BE%E7%BD%AE/" style="font-size: 15px;">title设置</a> <a href="/tags/%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0/" style="font-size: 15px;">局部刷新</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">随笔</a> <a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 15px;">杂谈</a> <a href="/tags/ajax/" style="font-size: 15px;">ajax</a> <a href="/tags/slot/" style="font-size: 15px;">slot</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 15px;">性能优化</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">骑猪骑士.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>