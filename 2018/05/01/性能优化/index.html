<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="zz_xiaoming's blog."><meta name="keywords" content="博客, 前端, js"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>web前端性能优化 | zz_xiaoming's blog.</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">web前端性能优化</h1><a id="logo" href="/.">zz_xiaoming's blog.</a><p class="description">less talking, more working</p></div><div id="nav-menu"> <a href="/." class="current"><i class="fa fa-home">首页</i></a> <a href="/archives/"><i class="fa fa-archive">归档</i></a> <a href="/about/"><i class="fa fa-user">关于</i></a> <a href="/atom.xml"><i class="fa fa-rss">订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">web前端性能优化</h1><div class="post-meta"><a href="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/#comments" class="comment-count"></a><p><span class="date">May 01, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/f1.jpg" alt="湖" title="湖"></p><h2 id="Web前端性能优化——如何提高页面加载速度"><a href="#Web前端性能优化——如何提高页面加载速度" class="headerlink" title="Web前端性能优化——如何提高页面加载速度"></a>Web前端性能优化——如何提高页面加载速度</h2><a id="more"></a><hr><p><strong>前言：</strong></p><p>在同样的网络环境下，两个同样能满足你的需求的网站，一个“Duang”的一下就加载出来了，一个纠结了半天才出来，你会选择哪个？研究表明：用户最满意的打开网页时间是2-5秒，如果等待超过10秒，99%的用户会关闭这个网页。也许这样讲，各位还不会有太多感触，接下来我列举一组数据：Google网站访问速度每慢400ms就导致用户搜索请 求下降0.59%;Amazon每增加100ms网站延迟将导致收入下降1%;雅虎如果有400ms延迟会导致流量下降5-9%。网站的加载速度严重影响了用户体验，也决定了这个网站的生死存亡。</p><p>可能有人会说：网站的性能是后端工程师的事情，与前端并无多大关系。我只能说，too young too simple。事实上，只有10%~20%的最终用户响应时间是用在从Web服务器获取HTML文档并传送到浏览器的，那剩余的时间去哪儿了？来瞄一下<strong>性能黄金法则</strong>：</p><p>只有10% ~ 20%的最终用户响应时间花在了下载HTML文档上。其余的80% ~ 90%时间花在了下载页面中的所有组件上。</p><p>接下来我们将研究一下前端攻城狮如何来提高页面的加载速度。</p><blockquote><h3 id="一、减少HTTP请求"><a href="#一、减少HTTP请求" class="headerlink" title="一、减少HTTP请求"></a>一、减少HTTP请求</h3></blockquote><p>上面说到80%~90%时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。</p><p><strong>图片地图：</strong></p><p>假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。</p><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a1.png" alt="a1" title="a1"></p><p>服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应</p><p>客户端图片地图：直接将点击映射到操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"planets.jpg"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">usemap</span>=<span class="string">"#planetmap"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span> <span class="attr">id</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span> <span class="attr">href</span> =<span class="string">"venus.html"</span> <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span> <span class="attr">href</span> =<span class="string">"mercur.html"</span> <span class="attr">alt</span>=<span class="string">"Mercury"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span> <span class="attr">href</span> =<span class="string">"sun.html"</span> <span class="attr">alt</span>=<span class="string">"Sun"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"140,0,110,260"</span> <span class="attr">href</span> =<span class="string">"star.html"</span> <span class="attr">alt</span>=<span class="string">"Sun"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用图片地图的缺点：指定坐标区域时，矩形或圆形比较容易指定，而其它形状手工指定比较难</p><p><strong>CSS Sprites</strong></p><p><a href="https://www.toptal.com/developers/css/sprite-generator" target="_blank" rel="noopener">CSS Sprites地址推荐</a></p><p>CSS Sprites直译过来就是CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，然后通过CSS的一些技术布局到网页上。特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。</p><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a2.png" alt="a2" title="a2"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span id=<span class="string">"image1"</span> <span class="keyword">class</span>="<span class="symbol">nav</span>"&gt;&lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">span</span> <span class="symbol">id</span>="<span class="symbol">image2</span>" <span class="symbol">class</span>="<span class="symbol">nav</span>"&gt;&lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">span</span> <span class="symbol">id</span>="<span class="symbol">image3</span>" <span class="symbol">class</span>="<span class="symbol">nav</span>"&gt;&lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">span</span> <span class="symbol">id</span>="<span class="symbol">image4</span>" <span class="symbol">class</span>="<span class="symbol">nav</span>"&gt;&lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">span</span> <span class="symbol">id</span>="<span class="symbol">image5</span>" <span class="symbol">class</span>="<span class="symbol">nav</span>"&gt;&lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">div</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'E:/1.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#image1</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#image2</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: -<span class="number">95px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#image3</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: -<span class="number">185px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#image4</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: -<span class="number">275px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#image5</span> &#123;</span><br><span class="line">        <span class="attribute">background-position</span>: -<span class="number">366px</span> -<span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a3.png" alt="a3" title="a3"></p><p>PS：使用CSS Sprites还有可能降低下载量，可能大家会认为合并后的图片会比分离图片的总和要大，因为还有可能会附加空白区域。实际上，合并后的图片会比分离的图片总和要小，因为它降低了图片自身的开销，譬如颜色表、格式信息等。</p><p>字体图标</p><p>在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少http请求，字体图标还可以通过CSS来设置颜色、大小等样式，何乐而不为。</p><p>合并脚本 和样式表</p><p>将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。</p><p>然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。</p><blockquote><h3 id="二、使用CDN"><a href="#二、使用CDN" class="headerlink" title="二、使用CDN"></a>二、使用CDN</h3></blockquote><p>如果应用程序web服务器离用户更近，那么一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器离用户更近，则多个HTTP请求的响应时间将缩短。</p><p> CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。</p><p>CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力。</p><p>CDN的缺点：</p><p>1、响应时间可能会受到其他网站流量的影响。CDN服务提供商在其所有客户之间共享Web服务器组。<br>2、如果CDN服务质量下降了，那么你的工作质量也将下降<br>3、无法直接控制组件服务器</p><blockquote><h3 id="三、添加Expires头"><a href="#三、添加Expires头" class="headerlink" title="三、添加Expires头"></a>三、添加Expires头</h3></blockquote><p>页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。</p><p>Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如：</p><p>Expires: Fri, 18 Mar 2016 07:41:53 GMT</p><p>Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查</p><p>HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。</p><p>Cache-Control： max-age=12345600</p><p>若同时制定Cache-Control和Expires，则max-age将覆盖Expires头</p><blockquote><h3 id="四、压缩组件"><a href="#四、压缩组件" class="headerlink" title="四、压缩组件"></a>四、压缩组件</h3></blockquote><p>从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持</p><p>Accept-Encoding: gzip,deflate</p><p>如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的Content-Encoding来通知 Web客户端。</p><p>Content-Encoding: gzip</p><p><strong>代理缓存</strong></p><p>当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。</p><p>解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。</p><p>vary: Accept-Encoding</p><blockquote><h3 id="五、将样式表放在头部"><a href="#五、将样式表放在头部" class="headerlink" title="五、将样式表放在头部"></a>五、将样式表放在头部</h3></blockquote><p>首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。</p><p>我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。</p><p>将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西</p><blockquote><h3 id="六、将脚本放在底部"><a href="#六、将脚本放在底部" class="headerlink" title="六、将脚本放在底部"></a>六、将脚本放在底部</h3></blockquote><p>更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。</p><p>js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。</p><p>下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。</p><blockquote><h3 id="七、避免CSS表达式"><a href="#七、避免CSS表达式" class="headerlink" title="七、避免CSS表达式"></a>七、避免CSS表达式</h3></blockquote><p>CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">expression</span>(func(),document.body.clientWidth &gt; <span class="number">400</span> ? <span class="string">"400px"</span> : <span class="string">"auto"</span>);</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        n++;</span><br><span class="line"><span class="actionscript">        <span class="comment">// alert();</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(n);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a4.png" alt="a4" title="a4"></p><p>鼠标移动了几次，函数的运行次数轻而易举的达到了几千次，危险性显而易见。</p><p>如何解决：</p><p><strong>一次性表达式：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">expression</span>(func(this));</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(elem)</span> </span>&#123;</span></span><br><span class="line">        n++;</span><br><span class="line"><span class="javascript">        elem.style.width = <span class="built_in">document</span>.body.clientWidth &gt; <span class="number">400</span> ? <span class="string">'400px'</span> : <span class="string">"auto"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(n);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>事件处理机制</strong></p><p>用js事件处理机制来动态改变元素的样式，使函数运行次数在可控范围之内。</p><blockquote><h3 id="八、使用外部的JavaScript和CSS"><a href="#八、使用外部的JavaScript和CSS" class="headerlink" title="八、使用外部的JavaScript和CSS"></a>八、使用外部的JavaScript和CSS</h3></blockquote><p>内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。</p><p>影响因素：</p><p>1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。</p><p>2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。</p><p><strong>加载后下载</strong></p><p>有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成止呕动态加载外部组件，以便用户接下来的访问。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOnload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="string">"downloadFile()"</span>,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">window</span>.onload = doOnload;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">downloadFile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      downloadCss(<span class="string">"http://abc.com/css/a.css"</span>);</span><br><span class="line">      downloadJS(<span class="string">"http://abc.com/js/a.js"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">downloadCss</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</span><br><span class="line">     ele.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">     ele.type = <span class="string">"text/css"</span>;</span><br><span class="line">     ele.href = <span class="built_in">url</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">document</span>.body.appendChild(ele);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">downloadJS</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> ele = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">     ele.src = <span class="built_in">url</span>;</span><br><span class="line">     <span class="built_in">document</span>.body.appendChild(ele);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在该页面中，JavaScript和CSS被加载两次（内联和外部）。要使其正常工作，必须处理双重定义。将这些组件放到一个不可见的IFrame中是一个比较好的解决方式。</p><blockquote><h3 id="九、减少DNS查找"><a href="#九、减少DNS查找" class="headerlink" title="九、减少DNS查找"></a>九、减少DNS查找</h3></blockquote><p>当我们在浏览器的地址栏输入网址（譬如： <a href="http://www.baidu.com）" target="_blank" rel="noopener">www.baidu.com）</a> ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？</p><p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户</p><p>域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例：</p><hr><ol><li><p>Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。<br>注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看</p></li><li><p>如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.<br>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p></li><li><p>如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p></li><li><p>如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这个域名的IP地址，但是我知道 baidu.com 这个域的DNS地址，你去找它去，于是运营商的DNS又向 baidu.com 这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这个域名的IP地址是多少？），这个时候 baidu.com 域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 对应的IP地址，该进行一步的动作了。</p></li></ol><p>注：一般情况下是不会进行以下步骤的</p><p>如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤：<br>5. 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。</p><ol start="6"><li><p>如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器）</p></li><li><p>如果第6步也没有查询成功，那么客户端就要进行广播查找</p></li><li><p>如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）</p></li></ol><hr><p>如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。</p><p>DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p><p>当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。</p><p>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。</p><blockquote><h3 id="十、精简JavaScript"><a href="#十、精简JavaScript" class="headerlink" title="十、精简JavaScript"></a>十、精简JavaScript</h3></blockquote><p><strong>精简</strong></p><p>精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。</p><p><strong>混淆</strong></p><p>混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。</p><p>缺点：</p><p>混淆本身比较复杂，可能会引入错误。</p><p>需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。</p><p>混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。</p><p>在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。</p><p><strong>CSS的精简</strong></p><p>CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。</p><p>除了移除空白、注释之外，CSS可以通过优化来获得更多的节省：</p><p>合并相同的类；</p><p>移除不使用的类；</p><p>使用缩写，譬如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#111</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrong</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">0px</span>; </span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#111</span>;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面.right是正确的的写法，颜色使用缩写，使用0代替0px，合并可以合并的样式。另外，在精简的时候其实样式最后一行的’；’也是可以省略的。</p><p>来看看精简的例子：</p><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a5.png" alt="a5" title="a5"><br><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a6.png" alt="a6" title="a6"><br><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a7.png" alt="a7" title="a7"></p><p>以上分别是jquery-2.0.3的学习版（未精简）和精简版，可见精简文件的大小比源文件小了155k，而且，在精简版中jquery还做了混淆，譬如用e代替window等，从而获得最大的节省。</p><blockquote><h3 id="十一、避免重定向"><a href="#十一、避免重定向" class="headerlink" title="十一、避免重定向"></a>十一、避免重定向</h3></blockquote><p><strong>什么是重定向？</strong></p><p>重定向用于将用户从一个URL重新路由到另一个URL。</p><p><strong>常用重定向的类型</strong></p><p>301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。</p><p>302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。</p><p>304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。</p><p><strong>重定向如何损伤性能?</strong></p><p>当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。</p><p>来看一个实际例子：对于ASP.NET webform开发来说，对于新手很容易犯一个错误，就是把页面的连接写成服务器控件后台代码里，例如用一个Button控件，在它的后台click事件中写上：Response.Redirect(“”)；然而这个Button的作用只是转移URL，这是非常低效的做法，因为点击Button后，先发送一个Post请求给服务器，服务器处理Response.Redirect(“”)后就发送一个302响应给浏览器，浏览器再根据响应的URL发送GET请求。正确的做法应该是在html页面直接使用a标签做链接，这样就避免了多余的post和重定向。</p><p><strong>重定向的应用场景</strong></p><ol><li>跟踪内部流量</li></ol><p>重定向经常用于跟踪用户流量的方向,当拥有一个门户主页的时候，同时想对用户离开主页后的流量进行跟踪，这时可以使用重定向。例如: 某网站主页新闻的链接地址 <a href="http://a.com/r/news" target="_blank" rel="noopener">http://a.com/r/news</a> ，点击该链接将产生301响应，其Location被设置为 <a href="http://news.a.com" target="_blank" rel="noopener">http://news.a.com</a> 。通过分析a.com的web服务器日志可以得知人们离开首页之后的去向。</p><p>我们知道重定向是如何损伤性能的，为了实现更好的效率，可以使用Referer日志来跟踪内部流量去向。每个HTTP请求都有一个Referer表示原始请求页(除了从书签打开或直接键入URL等操作)，记录下每个请求的Referer，就避免了向用户发送重定向，从而改善了响应时间。</p><ol start="2"><li>跟踪出站流量</li></ol><p>有时链接可能将用户带离你的网站，在这种情况下，使用Referer就不太现实了。</p><p>同样也可以使用重定向来解决跟踪出站流量问题。以百度搜索为例，百度通过将每个链接包装到一个302重定向来解决跟踪的问题，例如搜索关键字“前端性能优化”，搜索结果中的一个URL为 <a href="https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297" target="_blank" rel="noopener">https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297</a> ，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生302重定向，将页面转到目标页面（待修改，求大神们给我指正））</p><p>除了重定向外，我们还可以选择使用信标(beacon)——一个HTTP请求，其URL中包含有跟踪信息。跟踪信息可以从信标Web服务器的访问日记中提取出来，信标通常是一个1px*1px的透明图片，不过204响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。</p><blockquote><h3 id="十二、删除重复脚本"><a href="#十二、删除重复脚本" class="headerlink" title="十二、删除重复脚本"></a>十二、删除重复脚本</h3></blockquote><p>在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多次。</p><p>重复的脚本会造成不必要的HTTP请求（如果没有缓存该脚本的话），并且执行多余的JavaScript浪费时间，还有可能造成错误。</p><p>如何避免重复脚本呢？</p><ol><li><p>形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是必要的，所以需要对脚本进行一个良好的组织。</p></li><li><p>实现脚本管理器模块。</p></li></ol><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertScript</span><span class="params">($file)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(hadInserted($file)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      exeInsert($file);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span>(hasDependencies($file)) &#123;</span><br><span class="line">  </span><br><span class="line">          $deps = getDependencies($file);</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">foreach</span> ($deps <span class="keyword">as</span> $script) &#123;</span><br><span class="line">             insertScript($script);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">echo</span> <span class="string">"&lt;script type='text/javascript' src='"</span>.getVersion($file).<span class="string">"'&gt;&lt;/script&gt;"</span>;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先检查是否插入过，如果插入过则返回。如果该脚本依赖其它脚本，则被依赖的脚本也会被插入。最后脚本被传送到页面，getVersion会检查脚本并返回追加了对应版本号的文件名，这样如果脚本的版本变化了，那么以前浏览器缓存的就会失效。</p><blockquote><h3 id="十三、配置ETag"><a href="#十三、配置ETag" class="headerlink" title="十三、配置ETag"></a>十三、配置ETag</h3></blockquote><p>以前浏览器缓存的就会失效。</p><p><strong>什么是ETag？</strong></p><p>实体标签(EntityTag)是唯一标识了一个组件的一个特定版本的字符串，是web服务器用于确认缓存组件的有效性的一种机制，通常可以使用组件的某些属性来构造它。</p><p><strong>条件GET请求</strong></p><p>如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。</p><p>那么服务器是根据什么判断缓存是否还有效呢?有两种方式：</p><p>ETag（实体标签）；</p><p>最新修改日期；</p><p><strong>最新修改日期</strong></p><p>原始服务器通过Last-Modified响应头来返回组件的最新修改日期。</p><p>举个栗子：</p><p>当我们不带缓存访问 <a href="http://www.google.com.hk" target="_blank" rel="noopener">www.google.com.hk</a> 的时候，我们需要下载google的logo，这时会发送这样一个HTTP请求：</p><p><strong>Request：</strong></p><hr><p>GET googlelogo_color_272x92dp.png HTTP 1.1<br>Host: <a href="http://www.google.com.hk" target="_blank" rel="noopener">www.google.com.hk</a></p><hr><p><strong>Response:</strong></p><hr><p>HTTP 1.1 200 OK<br>Last-Modified:Fri, 04 Sep 2015 22:33:08 GMT</p><hr><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a8.png" alt="a8" title="a8"></p><p>当需要再次访问相同组件的时候，同时缓存已经过期，浏览器会发送如下条件GET请求：</p><p><strong>Request：</strong></p><hr><p>GET googlelogo_color_272x92dp.png HTTP 1.1<br>If-Modified-Since:Fri, 04 Sep 2015 22:33:08 GMT<br>Host: <a href="http://www.google.com.hk" target="_blank" rel="noopener">www.google.com.hk</a></p><hr><p><strong>Response:</strong></p><hr><p>HTTP 1.1 304 Not Modified</p><hr><p><img src="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/a9.png" alt="a9" title="a9"></p><p><strong>实体标签</strong></p><p>ETag提供了另外一种方式，用于检测浏览器缓存中的组件与原始服务器上的组件是否匹配。摘抄自书上的例子：</p><p>不带缓存的请求：</p><p><strong>Request：</strong></p><hr><p>GET /i/yahoo/gif HTTP 1.1<br>Host: us.yimg.com</p><hr><p><strong>Response:</strong></p><hr><p>HTTP 1.1 200 OK<br>Last-Modified:Tue,12 Dec 200603:03:59 GMT<br>ETag:”10c24bc-4ab-457elc1f“</p><hr><p>再次请求相同组件:</p><p><strong>Request：</strong></p><hr><p>GET /i/yahoo/gif HTTP 1.1<br>Host: us.yimg.com<br>If-Modified-Since:Tue,12 Dec 200603:03:59 GMT<br>If-None-Match:”10c24bc-4ab-457elc1f“</p><hr><p><strong>Response:</strong></p><hr><p>HTTP 1.1 304 Not Midified</p><hr><p><strong>为什么要引入ETag?</strong></p><p>ETag主要是为了解决Last-Modified无法解决的一些问题：</p><ol><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒);</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ol><p><strong>ETag带来的问题</strong></p><p>ETag的问题在于通常使用某些属性来构造它，有些属性对于特定的部署了网站的服务器来说是唯一的。当使用集群服务器的时候，浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求，ETag就会出现不匹配的状况。例如：使用inode-size-timestamp来生成ETag，文件系统使用inode存储文件类型、所有者、组和访问模式等信息，在多台服务器上，就算文件大小、权限、时间戳等都相同，inode也是不同的。</p><p><strong>最佳实践</strong></p><ol><li><p>如果使用Last-Modified不会出现任何问题，可以直接移除ETag，google的搜索首页则没有使用ETag。</p></li><li><p>确定要使用ETag，在配置ETag的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用size-timestamp来生成时间戳。</p></li></ol><blockquote><h3 id="十四、使Ajax可缓存"><a href="#十四、使Ajax可缓存" class="headerlink" title="十四、使Ajax可缓存"></a>十四、使Ajax可缓存</h3></blockquote><p>维基百科中这样定义Ajax：</p><hr><p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。Ajax的概念由杰西·詹姆士·贾瑞特所提出。</p><p>传统的Web应用允许用户端填写表单（form），当提交表单时就向Web服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。</p><p>与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。</p><p>类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。而客户端与服务器也并不需要异步。一些基于AJAX的“派生／合成”式（derivative/composite）的技术也正在出现，如AFLAX。</p><hr><p>Ajax的目地是为突破web本质的开始—停止交互方式，向用户显示一个白屏后重绘整个页面不是一种好的用户体验。</p><p><strong>异步与即时</strong></p><p>Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。</p><p>用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动请求是基于用户当前的操作而发起的</p><p><strong>什么样的AJAX请求可以被缓存？</strong></p><p>POST的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（可以在服务器端对数据进行缓存，以便提高处理速度）</p><p>GET的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的AJAX请求，不会重复在服务器执行，而是返回304。</p><p><strong>Ajax请求使用缓存</strong></p><p>在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度。</p><blockquote><h3 id="十四、减少cookie传输"><a href="#十四、减少cookie传输" class="headerlink" title="十四、减少cookie传输"></a>十四、减少cookie传输</h3></blockquote><p>一方面，cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。</p><blockquote><h3 id="十五、Javascript代码优化"><a href="#十五、Javascript代码优化" class="headerlink" title="十五、Javascript代码优化"></a>十五、Javascript代码优化</h3></blockquote><p><strong>(1). DOM</strong></p><p>a.HTML Collection（HTML收集器，返回的是一个数组内容信息）</p><p>　　在脚本中 document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合” 包括读取集合的 length属性、访问集合中的元素。</p><p>　　因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。<br>　　<br>b. Reflow &amp; Repaint　<br>　<br>　　除了上面一点之外， DOM操作还需要考虑浏览器的Reflow和Repaint ，因为这些都是需要消耗资源的。</p><p><strong>(2). 慎用 with</strong>　</p><p>with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。</p><p>　　因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。</p><p><strong>(3). 避免使用 eval和 Function</strong></p><p>每次 eval 或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。</p><p>　　eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。</p><p>　　Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。</p><p>　　此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p><p><strong>(4). 减少作用域链查找</strong></p><p>前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。</p><p>低效率的写法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=<span class="string">"font-size:14px;"</span>&gt;<span class="comment">// 全局变量   </span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">1</span>;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span><span class="params">(info)</span></span>&#123;   </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">100000</span>; i--;)&#123;   </span><br><span class="line">        <span class="comment">//每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次   </span></span><br><span class="line">        globalVar += i;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;   </span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>更高效的写法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=<span class="string">"font-size:14px;"</span>&gt;<span class="comment">// 全局变量   </span></span><br><span class="line"><span class="keyword">var</span> globalVar = <span class="number">1</span>;   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCallback</span><span class="params">(info)</span></span>&#123;   </span><br><span class="line">    <span class="comment">//局部变量缓存全局变量   </span></span><br><span class="line">    <span class="keyword">var</span> localVar = globalVar;   </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">100000</span>; i--;)&#123;   </span><br><span class="line">    <span class="comment">//访问局部变量是最快的   </span></span><br><span class="line">    localVar += i;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//本例中只需要访问 2次全局变量  </span></span><br><span class="line">    在函数中只需要将 globalVar中内容的值赋给localVar 中  </span><br><span class="line">    globalVar = localVar;   </span><br><span class="line">&#125;  </span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>此外，要减少作用域链查找还应该减少闭包的使用。</p><p><strong>(5). 数据访问</strong></p><p>　　Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：<br>　　a. 对任何对象属性的访问超过 1次<br>　　b. 对任何数组成员的访问次数超过 1次<br>　　另外，还应当尽可能的减少对对象以及数组深度查找。</p><p><strong>(6). 字符串拼接</strong></p><p>在 Javascript中使用”+”号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。</p><blockquote><h3 id="十六、CSS选择符优化"><a href="#十六、CSS选择符优化" class="headerlink" title="十六、CSS选择符优化"></a>十六、CSS选择符优化</h3></blockquote><p>在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如</p><p>#toc A { color: #444; }</p><p>这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项。</p><blockquote><h3 id="十七、尽量少用iframe"><a href="#十七、尽量少用iframe" class="headerlink" title="十七、尽量少用iframe"></a>十七、尽量少用iframe</h3></blockquote><p>在写网页的时候，我们可能会用到iframe，iframe的好处是它完全独立于父文档。iframe中包含的JavaScript文件访问其父文档是受限的。例如，来自不同域的iframe不能访问其父文档的Cookie。</p><p><strong>开销最高的DOM元素</strong></p><p>通常创建iframe元素的开销要比创建其它元素的开销高几十倍甚至几百倍。</p><p><strong>iframe阻塞onload事件</strong></p><p>通常我们会希望window.onload事件能够尽可能触发，原因如下：</p><p>1、我们可能在onload事件处理函数中编写了用于初始化UI的代码；<br>2、onload事件触发时，浏览器停止“忙指示器”，并向用户反馈页面已经准备就绪。<br>3、部分低版本浏览器（IE6、IE7、IE8、Safari3、Safari4、Chrome1、Chrome2等）只有onload事件触发之后才会触发unload事件。有时，我们会把一些重要的操作和window的unload事件绑定在一起。例如，减少内存泄露的代码。如果onload花费时间太长，用户可能会离开页面，那么在这些浏览器中unload可能就永远不会执行了。</p><p>通常情况下，iframe中的内容对页面来说不是很重要的（譬如第三方的广告），我们不应该因为这些内容而延迟window.onload事件的触发。</p><p>综上，即使iframe是空的，其开销也会很高，而且他会阻塞onload事件。所以，我们应该尽可能避免iframe的使用。</p></div><div class="post-copyright"><blockquote><p>原文作者: 骑猪骑士</p><p>原文链接: <a href="http://zhaokunming.xyz/2018/05/01/性能优化/">http://zhaokunming.xyz/2018/05/01/性能优化/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/11/21/hello-world/" class="pre">Hello World</a><a href="/2018/04/18/withRouter%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/" class="next">withRouter的作用</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk=new Gitalk({clientID:"b9866c2ced487dfb61db",clientSecret:"802b6c3f8fe51c7e135315c617f51de05ecd97f1",repo:"gitalk.github.io",owner:"pretendtobehappy",admin:["pretendtobehappy"],id:md5(window.location.pathname),distractionFreeMode:!1,language:"zh-CN",pagerDirection:"last"});gitalk.render("container")</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web前端性能优化——如何提高页面加载速度"><span class="toc-text">Web前端性能优化——如何提高页面加载速度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、减少HTTP请求"><span class="toc-text">一、减少HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、使用CDN"><span class="toc-text">二、使用CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、添加Expires头"><span class="toc-text">三、添加Expires头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、压缩组件"><span class="toc-text">四、压缩组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、将样式表放在头部"><span class="toc-text">五、将样式表放在头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、将脚本放在底部"><span class="toc-text">六、将脚本放在底部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、避免CSS表达式"><span class="toc-text">七、避免CSS表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、使用外部的JavaScript和CSS"><span class="toc-text">八、使用外部的JavaScript和CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九、减少DNS查找"><span class="toc-text">九、减少DNS查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十、精简JavaScript"><span class="toc-text">十、精简JavaScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十一、避免重定向"><span class="toc-text">十一、避免重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十二、删除重复脚本"><span class="toc-text">十二、删除重复脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十三、配置ETag"><span class="toc-text">十三、配置ETag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十四、使Ajax可缓存"><span class="toc-text">十四、使Ajax可缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十四、减少cookie传输"><span class="toc-text">十四、减少cookie传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十五、Javascript代码优化"><span class="toc-text">十五、Javascript代码优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十六、CSS选择符优化"><span class="toc-text">十六、CSS选择符优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十七、尽量少用iframe"><span class="toc-text">十七、尽量少用iframe</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"> <i class="fa fa-xie">最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/21/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/01/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">web前端性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/withRouter%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/">withRouter的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/03/css3%E8%87%AA%E9%80%82%E5%BA%94%E6%B3%95%E5%AE%9D/">css3自适应法宝</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/26/%E4%BD%BF%E7%94%A8Promise%E5%B0%81%E8%A3%85%E7%AE%80%E5%8D%95Ajax%E6%96%B9%E6%B3%95/">使用Promise封装简单Ajax方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/cssText%E7%9A%84%E7%94%A8%E6%B3%95/">cssText的用法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/30/vuex%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/">vuex的语法糖</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/">图片懒加载</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/start/">总要写点什么</a></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-biao">标签</i></div><div class="tagcloud"><a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:15px">生活</a> <a href="/tags/css3/" style="font-size:15px">css3</a> <a href="/tags/html/" style="font-size:15px">html</a> <a href="/tags/js/" style="font-size:15px">js</a> <a href="/tags/css/" style="font-size:15px">css</a> <a href="/tags/react/" style="font-size:15px">react</a> <a href="/tags/withRouter/" style="font-size:15px">withRouter</a> <a href="/tags/title%E8%AE%BE%E7%BD%AE/" style="font-size:15px">title设置</a> <a href="/tags/%E8%87%AA%E9%80%82%E5%BA%94/" style="font-size:15px">自适应</a> <a href="/tags/start/" style="font-size:15px">start</a> <a href="/tags/ajax/" style="font-size:15px">ajax</a> <a href="/tags/vue/" style="font-size:15px">vue</a> <a href="/tags/vuex%E8%AF%AD%E6%B3%95%E7%B3%96/" style="font-size:15px">vuex语法糖</a> <a href="/tags/vue%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/" style="font-size:15px">vue辅助函数</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:15px">前端</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size:15px">性能优化</a></div></div><div class="widget"><div class="widget-title"> <i class="fa fa-archive">归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">5</span></li></ul></div><div class="widget"><div class="widget-title"> <i class="fa fa-you">友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> | <a href="/atom.xml">订阅本站</a> | <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p> <span>Copyright &copy;<a href="/." rel="nofollow">骑猪骑士.</a></span> <span>Theme by <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake.</a></span> <span>Count by <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">busuanzi.</a></span> <span>Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>