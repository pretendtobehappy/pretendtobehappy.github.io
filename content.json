[{"title":"Hello World","date":"2019-11-21T01:04:24.750Z","path":"2019/11/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"withRouter的作用","date":"2018-04-18T12:35:03.000Z","path":"2018/04/18/withRouter的作用和一个简单应用/","text":"withRouter的作用和一个简单应用 作用： 把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 一：如何使用withRouter： 比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下：设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 二：介绍一个简单应用 可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 图片显示不出来，所以我描述一下情况： 点击指定的路由跳转，doument.title属性，即页面标签头的值变为指定title","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"withRouter","slug":"withRouter","permalink":"http://yoursite.com/tags/withRouter/"},{"name":"title设置","slug":"title设置","permalink":"http://yoursite.com/tags/title%E8%AE%BE%E7%BD%AE/"}]},{"title":"css3自适应法宝","date":"2018-02-03T04:17:33.000Z","path":"2018/02/03/css3自适应法宝/","text":"css3自适应法宝fill-available、fit-content、max-content、min-content fill-available fill-available表示撑满可用空间（包括高度，宽度），下面举个例子： 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; width: 60%; height: 500px; border: 1px solid #f00; margin: 20px auto 0; &#125; .son&#123; width: -webkit-fill-available; background: #ff0; height:200px;/*高也可以是fill-available*/ &#125; &lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fill-available对于行内块（inline-block）和块元素（block）起作用,这个要注意哦，等高布局就更简单了 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; height: 200px; &#125; .son&#123; width: 30%; height: -webkit-fill-available; background: #f00; display: inline-block; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fit-content fit-content表示宽度缩小到内容的宽度，下面have a 栗子 123456789&lt;style type=\"text/css\"&gt; div&#123; background-color: #f00; width:-webkit-fit-content; &#125;&lt;/style&gt;&lt;div&gt; 师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt; 本来作为块元素的div会继承父级的宽度，然而加fit-content宽度就会缩小到内容宽度,水平居中margin:auto max-content max-conten表示用内部元素宽度值最大的那个元素的宽度作为最终容器的宽度。简单了说就是文字不换行。咱们去吃个栗子就ok了 1234567891011&lt;style type=\"text/css\"&gt; .box&#123; width:-webkit-max-content; &#125; .son&#123; background: #ff0; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt; min-content min-content表示用内部元素最小宽度值最大的那个元素的宽度作为最终容器的宽度。这个最小宽度值有最大什么意思，如果是图片的话最小宽度值就是图片所呈现的宽度，如果是汉字就是一个字的宽度，如果是英文就是单词的宽度，ok了。 123456789101112131415&lt;style&gt; .box&#123; width:-webkit-min-content; border:1px solid pink; &#125; .brother&#123; width: 120px; height: 20px; background: #f00; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"brother\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"},{"name":"自适应","slug":"自适应","permalink":"http://yoursite.com/tags/%E8%87%AA%E9%80%82%E5%BA%94/"}]},{"title":"使用Promise封装简单Ajax方法","date":"2017-12-26T10:47:31.000Z","path":"2017/12/26/使用Promise封装简单Ajax方法/","text":"使用Promise封装简单Ajax方法 在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现： 123456function callback() &#123; console.log('Done');&#125;console.log('before setTimeout()');setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log('after setTimeout()'); 观察上述代码执行，在Chrome的控制台输出可以看到： 1234before setTimeout()after setTimeout()(等待1秒后)Done 可见，异步操作会在将来的某个时间点触发一个函数调用。 AJAX就是典型的异步操作。 GET 1234567891011121314151617181920function getJSON (url) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125; POST 1234567891011121314151617181920function postJSON(url, data) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open(\"POST\", url, true) xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125; 其实Promise就是一个天然的try…catch 1234567getJSON('/api/v1/xxx') // =&gt; 这里面是就try.catch( error =&gt; &#123; // dosomething // =&gt; 这里就是catch到了error，如果处理error以及返还合适的值&#125;).then( value =&gt; &#123; // dosomething // 这里就是final&#125;) 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]},{"title":"cssText的用法","date":"2017-11-08T04:26:26.000Z","path":"2017/11/08/cssText的用法/","text":"cssText的用法以及特点 cssText 本质是什么？ cssText 的本质就是设置 HTML 元素的 style 属性值。 cssText 怎么用？ 1document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\"; cssText 返回值是什么？ 在某些浏览器中（比如 Chrome），你给他赋什么值，它就返回什么值。在 IE 中则比较痛苦，它会格式化输出、会把属性大写、会改变属性顺序、会去掉最后一个分号，比如： 123document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\";alert(document.getElementById(\"d1\").style.cssText); 在 IE 中值为：FONT-SIZE: 13px; COLOR: red cssText的使用优势 一般情况下我们用js设置元素对象的样式会使用这样的形式： 1234var element= document.getElementById(\"id\"); element.style.width=\"20px\"; element.style.height=\"20px\"; element.style.border=\"solid 1px red\"; 样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。 js中有一个cssText的方法： 语法为： 123obj.style.cssText=\"样式\";element.style.cssText=\"width:20px;height:20px;border:solid 1px red;\"; 这样就可以尽量避免页面reflow，提高页面性能。 但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。 为了解决这个问题，可以采用cssText累加的方法： 1Element.style.cssText += \"width:100px;height:100px;top:100px;left:100px;\" 因此，上面cssText累加的方法在IE中是无效的。 最后，可以在前面添加一个分号来解决这个问题： 1Element.style.cssText += \";width:100px;height:100px;top:100px;left:100px;\" 再进一步，如果前面有样式表文件写着 1div &#123; text-decoration:underline; &#125; 这个会被覆盖吗？不会！因为它不是直接作用于 HTML 元素的 style 属性。 具体案例分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;控制div属性&lt;/title&gt;&lt;style&gt;#outer&#123;width:500px;margin:0 auto;padding:0;text-align:center;&#125;#div1&#123;width:100px;height:100px;background:black;margin:10px auto;display:block;&#125;&lt;/style&gt;&lt;script&gt;var changeStyle = function (elem, attr, value)&#123; elem.style[attr] = value&#125;;window.onload = function ()&#123; var oBtn = document.getElementsByTagName(\"input\"); var oDiv = document.getElementById(\"div1\"); var oAtt = [\"width\",\"height\",\"background\",\"display\",\"display\"]; var oVal = [\"200px\",\"200px\",\"red\",\"none\",\"block\"]; for (var i = 0; i &lt; oBtn.length; i++) &#123; oBtn[i].index = i; oBtn[i].onclick = function () &#123; this.index == oBtn.length - 1 &amp;&amp; (oDiv.style.cssText = \"\"); changeStyle(oDiv, oAtt[this.index], oVal[this.index]) &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"outer\"&gt;&lt;input type=\"button\" value=\"变宽\" /&gt;&lt;input type=\"button\" value=\"变高\" /&gt;&lt;input type=\"button\" value=\"变色\" /&gt;&lt;input type=\"button\" value=\"隐藏\" /&gt;&lt;input type=\"button\" value=\"重置\" /&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"vuex的语法糖","date":"2017-09-30T02:18:56.000Z","path":"2017/09/30/vuex的语法糖/","text":"vuex的语法糖-辅助函数mapState , mapMutations , mapActions , mapGetters vuex五大核心 State Getters Mutations Actions Module 我们项目中需要的都是：state、getters、mutations、actions里面的东西调用方法和使用的位置也是有区别的不过vuex给我们提供了辅助函数：mapState , mapMutations , mapActions , mapGetters 调用 方法 辅助函数 state this.$store.state.xxx mapState getters this.$store.getters.xxx mapGetters mutations this.$store.commit(xxx) mapMutations actions this.$store.dispatch(xxx) mapActions 注意mapState和mapGetter的使用只能在computed计算属性中，mapMutations和mapActions使用的时候只能在methods中调用否则报错 如何实际使用辅助函数？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script&gt;import &#123; mapState , mapMutations , mapActions , mapGetters &#125; from 'vuex';export default &#123; data()&#123; return&#123; &#125; &#125;, computed:&#123; ...mapState(&#123; counts:(state) =&gt; state.count &#125;), //mapState就等于下面这个 // counts()&#123; // return this.$store.state.count // &#125;, ...mapGetters(&#123; getternum:'doneTodos' &#125;), //mapGetters就等于下面的这个 // getternum()&#123; // return this.$store.getters.doneTodos // &#125; &#125;, methods:&#123; ...mapMutations(&#123; addnum:'addNum' &#125;), addnum1()&#123; this.addnum() &#125;, //mapMutations就等于下面的这个 // addnum1()&#123; // this.$store.commit('addNum') // &#125;, ...mapActions(&#123; actionnum:'actionNumAdd' &#125;), actionnum6()&#123; this.actionnum() &#125;, //mapActions就等于下面的这个 // actionnum6()&#123; // this.$store.dispatch('actionNumAdd') // &#125; &#125;&#125;&lt;/script&gt; 辅助函数总结 当项目场景中我们需要大量的调用state中的值和触发多个actions的时候，我们还得写大量重复的代码，这时候辅助函数的作用就体现出来了，其实就是vuex的一个语法糖，使代码更简洁更优雅。","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex语法糖","slug":"vuex语法糖","permalink":"http://yoursite.com/tags/vuex%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"name":"vue辅助函数","slug":"vue辅助函数","permalink":"http://yoursite.com/tags/vue%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"}]},{"title":"图片懒加载","date":"2017-08-11T01:12:46.000Z","path":"2017/08/11/图片懒加载/","text":"前端实现图片懒加载（lazyload）的两种方式 在实际的项目开发中，我们通常会遇见这样的场景：一个页面有很多图片，而首屏出现的图片大概就一两张，那么我们还要一次性把所有图片都加载出来吗？显然这是愚蠢的，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，技术上现实其中要用的技术就是图片懒加载–到可视区域再加载。 思路： 将页面里所有img属性src属性用data-xx代替，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。也就是说，我们在开始先加载一张图片，这张图片作为所有img的初始src属性，加载一张图片的速度肯定会比加载十张图片的速度快，当我们需要看到img真正要展示的效果时，即出现在用户的可视区域内时，我们在即将进入用户可视区域的时候将img的src属性替换为真实路径，从而实现懒加载。 这就需要监听scroll属性了 关于各种宽高： 12345678910111213页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 示例：jqueryLazyload方式 下载地址：https://github.com/helijun/helijun/blob/master/plugin/lazyLoad/jquery.lazyload.js 123&lt;section class=\"module-section\" id=\"container\"&gt; &lt;img class=\"lazy-load\" data-original=\"../static/img/loveLetter/teacher/teacher1.jpg\" width=\"640\" height=\"480\" alt=\"测试懒加载图片\"/&gt;&lt;/section&gt; 12345678910111213require.config(&#123; baseUrl : \"/static\", paths: &#123; jquery:'component/jquery/jquery-3.1.0.min' jqueryLazyload: 'component/lazyLoad/jquery.lazyload',//图片懒加载 &#125;, shim: &#123; jqueryLazyload: &#123; deps: ['jquery'], exports: '$' &#125; &#125;&#125;); 12345678910111213141516require( [ 'jquery', 'jqueryLazyload' ], function($)&#123; $(document).ready(function() &#123; $(\"img.lazy-load\").lazyload(&#123; effect : \"fadeIn\", //渐现，show(直接显示),fadeIn(淡入),slideDown(下拉) threshold : 180, //预加载，在图片距离屏幕180px时提前载入 event: 'click', // 事件触发时才加载，click(点击),mouseover(鼠标划过),sporty(运动的),默认为scroll（滑动） container: $(\"#container\"), // 指定对某容器中的图片实现效果 failure_limit：2 //加载2张可见区域外的图片,lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况 &#125;); &#125;); &#125;); 为了代码可读性，属性值我都写好了注释。值得注意的是预制图片属性为data-original，并且最好是给予初始高宽占位，以免影响布局，当然这里为了演示我是写死的640x480，如果是响应式页面，高宽需要动态计算。 或者使用纯jquery 123456&lt;style&gt; img&#123; width: 300px; height: 300px; &#125;&lt;/style&gt;//这里给所有图片一个固定大小，为了美观 12345678910&lt;body&gt; &lt;ul&gt;//这里给几张图片简单模拟效果 &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060304326.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060308503.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602395423.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602573572.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603021166.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603062432.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt; let imgs=document.querySelectorAll('img') loadImg(imgs) window.onscroll=function()&#123; loadImg(imgs) &#125; function loadImg(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; if(arr[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight &amp;&amp; !arr[i].isLoad)&#123; arr[i].isLoad = true; // arr[i].style.cssText=\"opacity:0.3\" setTimeout(function()&#123; arr[i].style.cssText='opacity:1;transition:3s;' &#125;,500) aftImg(arr[i],arr[i].getAttribute('data')) &#125; &#125; &#125; function aftImg(obj,url)&#123; var Img=new Image() Img.onload=function()&#123; obj.src=Img.src &#125; Img.src=url; &#125;&lt;/script&gt; echo.js方式 介绍了一款非常简单实用轻量级的图片延时加载插件echo.js，如果你的项目中没有依赖jquery，那么这将是个不错的选择，50行代码，压缩后才1k。当然你完全可以集成到自己项目中去！ 下载地址：https://github.com/helijun/helijun/tree/master/plugin/echo 123456&lt;style&gt; .demo img &#123; width: 736px; height: 490px; background: url(images/loading.gif) 50% no-repeat;&#125;&lt;/style&gt; 123&lt;div class=\"demo\"&gt; &lt;img class=\"lazy\" src=\"images/blank.gif\" data-echo=\"images/big-1.jpg\"&gt;&lt;/div&gt; 12345678910&lt;script src=\"js/echo.min.js\"&gt;&lt;/script&gt;&lt;script&gt;Echo.init(&#123; offset: 0,//离可视区域多少像素的图片可以被加载 throttle: 0 //图片延时多少毫秒加载&#125;); &lt;/script&gt; 说明：blank.gif是一张背景图片，包含在插件里了。图片的宽高必须设定，当然，可以使用外部样式对多张图片统一控制大小。data-echo指向的是真正的图片地址。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"总要写点什么","date":"2017-07-14T01:25:57.000Z","path":"2017/07/14/start/","text":"本博开博文章，以祭奠流逝的时间 今天是个好日子，在经历了无数的挫折之后，我终于也是拥有了一个自己的博客网站。 仿佛每个人都要写一下开博文章，我也就写一下吧，一方面是为了记录我搭建博客的心酸，另一方面也回忆一下过去，展望一下未来。 怎么萌生一个搭建个人博客的念头的呢？这个没有确切的起点，起初我的笔记，工作经验什么的都写在了印象笔记里面，也就是记录一下生活，工作的问题，但大多只是记录，没有太多的思考。而管理个人博客就要花更多的时间去管理、维护，更多的这是属于自己的小空间。同时，我看到网站上的博客越来越多，而且也很方便，可以和更多的技术大牛沟通，交流技术。这样看来，搭建个人博客还是很有必要的（我是这样说服自己的）。 搭建之路很漫长，本来可以一两天搞定的事情，我花了一个多星期。原因，主要是我的环境坏掉了。好像hexo都有一个弊端吧，就是init只能一个，再多就会报错。不可修复的那种，最重要的是不要把第一次init的文件删了。我就是死在的这一步。当时请教了一些人，没有解决，还衍生出了其他的错误。环境坏了能怎么办，心灰意冷只能换电脑。不过好在成功搭建，于是才有了它。这还是一个看脸的时代，好的皮肤可能比操作还要重要，所以，又花费时间找了个还不错的主题。这里问题就不再详述了。总之，它就这样走进我的生活当中。过程很残忍，却被成功的喜悦覆盖了。 现在看来，搭建博客很简单吗，，，对。不过，有句话说，坚持难，例子，就是苏格拉底的例子。要持续更新博客，这可是个技术活。思考，这是必不可少的，同时，博客可能不止自己看，所，应该让大多数的人看懂，这很重要。多长时间更一篇，这个，还没想好，不过，要有时间，要坚持，坚持就是胜利。 这里引进胡伟煌的一段话：“花费了这么多时间和精力，对我个人来说是否有什么影响，应该是说找到了一种比较笨的学习方式。写博客是很耗时间的，需要将你学习到的东西通过自己认为比较简练的语言归纳整理，并且有条理或系统地去让别人更容易读懂，在这过程中自己的总结归纳能力等可以得到锻炼，而有的知识你以为懂了，当要写出来的时候会发现好像还没懂，这时候也可以再去思考这个知识。当形成了自己的知识体系后，即时你哪天忘记了你写的内容，也可以很快的找到答案所在的地方。就好比开卷考试，当你记不住答案或者也不一定要记住答案是什么，只需要知道在哪里可以快速找到答案就够了。如果可以快速有效地解决问题，也不一定要关心你是怎么解决的。当你学的东西越来越多，你会发现你不懂的也越来越多，好比一个圆，圆内的面积越大，圆外接触的不懂的东西也越多。” 第一：生活 搭建博客的初衷，是沉淀一些自己知识、技能的记录。我对技术非常好奇，不断去尝试，各种摸索、各种分析。生活不仅仅只是上班下班，在上班的过程里面，还有那么一些尝试，让我尝试完，积累知识，然后好好沉淀下。 我一直都是一个很懂得“接受”的人，为什么说是接受呢？因为我觉得，我在生活中经历过的大大小小的各种事情，都是对自己的考验，按照市面上的一句话来说，就是感恩苦难。当然苦难本身是不值得感恩的，胡歌在采访中说，苦难本身是不值得感恩的，苦难带来的伤痛是无法抹去的。我真正要感谢的是自己在经历了各种事情之后所积累的经验与能力。所以说，我在碰到困难的时候第一想的不是放弃，而是尝试解决，就比如我在编程过程中，解决问题的最好方法是解决问题本身，而不是换条路达到解决问题的目的。当然，二者兼得更好。 或者现实一点的说法就是，我在不断增强自己的实力。活到老，学到老。我希望我的一生能够贯彻这一点。 第二：未来 毕业有一段时间了，工作暂时找好了，工作失误免不了被老板骂，一直没有离职。一方面，确实是自己做错了，无可厚非，错了就是错了，我也在积累项目错误的经验，为了以后再次碰到这种情况能快速解决。一方面，我觉得没必要记恨别人，人的一生也不过是白驹过隙，能让人生更有意义一些才会在闭上眼睛回望一生时嘴角上扬。而且，老板也不坏，人之初，性本善，当然也可能是我还没碰到所以才说出这样的话。这里，我要感谢我老板在我工作方面的照顾，批评我的错误是正常的，体谅员工的老板才是好老板，巧的是，我的老板就是这样的人。 对未来的规划，小时候，在电视上看职场情景，有赶地铁的人，拿着早餐路上吃的上班族，早上赶电梯，晚上外套一脱，躺床上。好像生活很单一，又很无聊。如今看来，似乎生活还有很多乐趣。工作也不是如僵尸一样低头看文档。现在，首先是挣钱吧，最主要的是养活自己，不至于看到有人帮助的时候一掏腰包两手空，然后努力工作，给父母更好的生活，闲暇时间还可以旅旅游，放松一下。然后感叹，这就是生活鸭。 未来可期！ 第三：时间 时间是个好东西，只喜多不喜少。 就比如，这篇博客吧，本来打算二十分钟写完的，结果，边想边写，就花费了四十多分钟。 最近遇到一些事情，逼迫自己去思考工作、生活的意义。才发现工作是忙了，但是得到的除了钱，好像什么都没有。 精神还是空虚着，能力还是没怎么提高，未来10年、20年，靠什么继续下去？ 开一个博客，对人生的一种坚持与新生，在未来，尝试不一样的事情，对生活，充满着期待！","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"},{"name":"start","slug":"start","permalink":"http://yoursite.com/tags/start/"}]}]