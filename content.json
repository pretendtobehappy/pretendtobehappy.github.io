[{"title":"redux状态管理框架","date":"2018-06-20T06:02:07.000Z","path":"2018/06/20/redux状态管理框架/","text":"Redux对于JavaScript应用而言是一个可预测状态的容器。换言之，它是一个应用数据流框架，而不是传统的像underscore.js或者AngularJs那样的库或者框架。 Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。 redux 是一个范用的状态管理框架主要是解决了组件间状态共享的问题原理是集中式管理 不是所有的项目都需要使用redux 流程 View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数 redux和flux的区别 Redux和Flux很像。主要区别在于Flux有多个可以改变应用状态的store，它通过事件来触发这些变化。组件可以订阅这些事件来和当前状态同步。 Redux没有分发器dispatcher，但在Flux中dispatcher被用来传递数据到注册的回调事件。另一个不同是Flux中有很多扩展是可用的，这也带来了一些混乱与矛盾 在redux当中只能定义一个可以更新状态的storeflux可以定义多个仓库redux把store和Dispatcher合并,结构更加简单清晰新增state,对状态的管理更加明确 redux和vuex的区别 改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可 redux的优点 redux把流程规范了，统一渲染根节点虽然对代码管理上规范了一些,只要有需要显示数据的组件，当相关数据更新时都会自动进行更新。减少手动编码量，提高编码效率。 redux的缺点 一个组件所需要的数据，当相关数据更新时，组件要重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 redux中有三个基本概念，Action，Reducer，Store。store 仓库 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器。 action 中发送过来的对象 必须有一个type属性reducer 他是一个纯函数 他会跟action发送过来的type类型做逻辑上的处理（使用switch方法进行判断） Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 约束：不得改写参数不能调用系统 I/O 的API不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 Redux核心API-reducer Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; Reducer拆分 12345import &#123;combineReducers&#125; from 'redux';Const reducer=combineReducers(&#123;Xxx:xxx(函数－业务逻辑)&#125;) Middleware的由来 在redux里，action仅仅是携带了数据的普通js对象。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发。 同步的情况下一切都很完美，但是reducer无法处理异步的情况。例如：我希望点击一个按钮，2秒之后更新视图，显示消息“Hi”。那么我们就需要在action和reducer中间架起一座桥梁来处理异步。这就是middleware。 参考代码： 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 这段代码的意思是，中间件这个桥梁接受到的参数action，如果不是function则和过去一样直接执行next方法(下一步处理)。相当于中间件没有做任何事。如果action是function，则先执行action，action的处理结束之后，再在action的内部调用dispatch。 Redux异步流 redux-thunk： redux-saga redux-promisestore.dispatch参数可以是一个function 使用方法：1.引入：import thunk from ‘redux-thunk’; 2.加入中间件const store = createStore(fetchReducer, applyMiddleware(thunk)); 基本结构 展示视图组件： View:视图组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, &#123; Component &#125; from 'react';import Store from './Store';import Action from './Action';export default class View extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; list:Store.getState().todolist, str:Store.getState().todostr &#125; this.changeItem=this.changeItem.bind(this) &#125; changeItem()&#123; this.setState(&#123; list:Store.getState().todolist, str:Store.getState().todostr &#125;) &#125; componentDidMount()&#123; Store.subscribe(this.changeItem) &#125; add()&#123; Store.dispatch(Action.addItem(this.refs.ipt.value)) // console.log(this.refs.ipt.value) this.refs.ipt.value='' &#125; del(index)&#123; Store.dispatch(Action.delItem(index)) &#125; show()&#123; // Store.dispatch(Action.toShow(this.refs.ipt2.value)) Store.dispatch((dispatch)=&gt;&#123; let timer=null; if(timer!==null)return; timer=setTimeout(()=&gt;&#123; dispatch(Action.toShow(this.refs.ipt2.value)) this.refs.ipt2.value='' timer=null &#125;,2000) &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;hahaha视图层&lt;/h2&gt; &lt;input type=\"text\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.add()&#125;&gt;添加&lt;/button&gt; &#123; this.state.list.map((item,i)=&gt;&#123; return( &lt;div key=&#123;i&#125;&gt; &lt;p&gt;&#123;item&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.del(i)&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; ) &#125;) &#125; &lt;hr/&gt; &lt;input type=\"text\" ref=\"ipt2\"/&gt; &lt;button onClick=&#123;()=&gt;this.show()&#125;&gt;展示&lt;/button&gt; &#123; &lt;p&gt;&#123;this.state.str&#125;&lt;/p&gt; &#125; &lt;/div&gt; ) &#125;&#125; Action： 1234567891011121314151617181920212223var Action = &#123; addItem(msg)&#123; return&#123; type:'ADD', text:msg &#125; &#125;, delItem(index)&#123; return&#123; type:'DEL', text:index &#125; &#125;, toShow(msg)&#123; return&#123; type:'SHOW', text:msg &#125; &#125;&#125;export default Action; Store: 1234567import &#123;createStore,applyMiddleware&#125; from 'redux';import Reducer from './Reducer';import thunk from 'redux-thunk'var Store=createStore(Reducer,applyMiddleware(thunk))export default Store; Reducer: 12345678910111213141516171819202122232425262728293031import &#123;combineReducers&#125; from 'redux';import List from './List'import Str from './Str';//拆分reducer写法var Reducer=combineReducers(&#123; todolist:List, todostr:Str&#125;)//不拆分reducer写法// var Reducer = ((state=[],action)=&gt;&#123;// switch (action.type) &#123;// case \"ADD\":// let arr=[...state]// arr.push(action.text)// return arr// case \"DEL\":// let arrs=[...state]// arrs.splice(action.text,1)// return arrs// default:// return state// &#125;// &#125;)export default Reducer; 如果将Reducer拆分的话，拆分的模块可以放在同级目录下，通过import引入： 拆分出的List模块： 1234567891011121314151617var List=((state=[],action)=&gt;&#123; switch (action.type) &#123; case \"ADD\": let arr=[...state] arr.push(action.text) return arr case \"DEL\": let arsr=[...state] arsr.splice(action.text,1) return arsr default: return state &#125;&#125;)export default List; 拆分出的Str模块： 12345678910111213var Str=((state='',action)=&gt;&#123; switch (action.type) &#123; case 'SHOW': let strings=state strings=action.text return strings default: return state &#125;&#125;)export default Str; 合并写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React,&#123;Component&#125; from 'react';import &#123;Map&#125; from 'immutable'import &#123;createStore&#125; from 'redux'const user=Map(&#123;name:''&#125;)const Action=&#123; taps(msg)&#123; return&#123; type:\"SAVE\", text:msg &#125; &#125;&#125;const Reducer=(state=user,action)=&gt;&#123; switch (action.type) &#123; case \"SAVE\": let names=state.set('name',action.text) return names; default: return state &#125;&#125;const Store=createStore(Reducer)class App extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; str:Store.getState().get('name') &#125; this.change=this.change.bind(this) &#125; tap()&#123; Store.dispatch(Action.taps(this.refs.ipt.value)) this.refs.ipt.value=\"\" &#125; change()&#123; this.setState(&#123; str:Store.getState().get('name') &#125;) &#125; componentDidMount()&#123; Store.subscribe(this.change) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;immutable&lt;/h2&gt; &lt;h2&gt;&#123;this.state.str&#125;&lt;/h2&gt; &lt;input type=\"text\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.tap()&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App;","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://zhaokunming.xyz/tags/redux/"}]},{"title":"flux状态管理器","date":"2018-05-25T01:24:10.000Z","path":"2018/05/25/flux状态管理器/","text":"Flux是Facebook用来构建客户端Web应用的应用架构。它利用单向数据流的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux。 四个组成部分 View： 视图层 Action（动作）：视图层发出的消息（比如click） 调用 dispatch方法发数据 Dispatcher（派发器）：用来接收Actions、执行回调函数-register 方法接收 Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面 流程： 1、用户访问 View2、View 发出用户的 Action3、Dispatcher 收到 Action，要求 Store 进行相应的更新4、Store 更新后，发出一个”change”事件5、View 收到”change”事件后，更新页面 dispatcher与action dispatcher是事件调度中心，flux模型的中心枢纽，管理着Flux应用中的所有数据流。它本质上是Store的回调注册。每个Store注册它自己并提供一个回调函数。当Dispatcher响应Action时，通过已注册的回调函数，将Action提供的数据负载发送给应用中的所有Store。应用层级单例 store Store中包含应用所有的数据 Store是应用中唯一的数据发生变更的地方 Store中没有赋值接口—所有数据变更都是由dispatcher发送到store，新的数据随着Store触发的change事件传回view。Store对外只暴露getter，不允许提供setter！！禁止在任何地方直接操作Store。 controller-view controller-view 可以理解成MVC模型中的controller，它一般由应用的顶层容器充当，负责从store中获取数据并将数据传递到子组件中。简单的应用一般只有一个controller-view，复杂应用中也可以有多个。controller-view是应用中唯一可以操作state的地方(setState()) view view(UI组件) ui-component 职责单一只允许调用action触发事件，数据从由上层容器通过属性传递过来。 actionCreator actionCreators是相对独立的，它作为语法上的辅助函数以action的形式使得dispatcher传递数据更为便利 flux核心api Action为对象方法 接收view的响应方法内部响应dispatcher对象的dispatch方法 Dispatch对象 由 flux对象引入Dispatcher对象 创建 Dispatch对象 new Dispatcher（）响应action的dispatch 方法 在dispatch对象中使用 register注册回调接收数据Dispatch.register((action)=&gt;{}) action参数为Action对象方法提供的数据判断符合条件 调用store的相应处理方法以及change事件 Store中change事件的触发通过this.emit 监听改变通过 this.on() 使用的是events模块中EventEmitter对象拷贝属性方法使用 object-assign 原生js依赖中的 assign对象 顶层容器中调用store的获取数据 以及在dom加载完成函数中调用store监听 环境搭建： 1npm install create-react-app -g 1create-react-app xxx(项目名) 安装依赖： 1npm i flux --savve-dev 目标目录： TodoController:顶层容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react';import View from './View';import Action from './Action'import Dispatch from './Dispatch'import Store from './Store'export default class TodoController extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; list:Store.getall() &#125; this.changeitem=this.changeitem.bind(this) //注意this指向 &#125; changeitem()&#123; this.setState(&#123;list:Store.getall()&#125;) &#125; addItem(msg)&#123; console.log(msg) Dispatch.dispatch(Action.addItem(msg)) // let arr=this.state.list // arr.push(msg) // this.setState(&#123; // list:arr // &#125;) &#125; delItem(index)&#123; console.log(index) Dispatch.dispatch(Action.delItem(index)) &#125; componentDidMount()&#123; Store.listenchange(this.changeitem) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;顶层容器&lt;/h2&gt; &lt;View title=&#123;(msg)=&gt;this.addItem(msg)&#125; list=&#123;this.state.list&#125; some=&#123;(index)=&gt;this.delItem(index)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 根组件App.js中引入，展示视图 View：视图 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';export default class View extends Component&#123; constructor(props)&#123; super(props) &#125; add()&#123; console.log(this.refs.ipt.value) this.props.title(this.refs.ipt.value) this.refs.ipt.value='' &#125; del(index)&#123; this.props.some(index) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;视图层&lt;/h2&gt; &lt;input type=\"text\" defaultValue=\"todolist\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.add()&#125;&gt;添加&lt;/button&gt; &#123; this.props.list.map((item,i)=&gt;&#123; return( &lt;div key=&#123;i&#125;&gt; &lt;p&gt;&#123;item&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.del(i)&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; ) &#125;&#125; Action:处理分类数据 12345678910111213141516var Action=&#123; addItem(msg)&#123; return&#123; actionType:'ADD', text:msg &#125; &#125;, delItem(index)&#123; return&#123; actionType:'DEL', text:index &#125; &#125;&#125;export default Action; Dispatch:接收数据 1234567891011121314151617import &#123;Dispatcher&#125; from 'flux'import Store from './Store'var Dispatch=new Dispatcher();Dispatch.register((action)=&gt;&#123; switch (action.actionType)&#123; case \"ADD\": //命令store进行数据变更 Store.add(action.text) Store.change() break; case \"DEL\": Store.del(action.text) Store.change() break; &#125;&#125;)export default Dispatch; Store:操作数据 1234567891011121314151617181920212223import &#123;EventEmitter&#125; from 'events';import assign from 'object-assign';var Store=assign(&#123;&#125;,EventEmitter.prototype,&#123; Todos:[], add(msg)&#123; this.Todos.push(msg) &#125;, change()&#123; this.emit('change') &#125;, listenchange(callback)&#123; this.on('change',callback) &#125;, getall()&#123; return this.Todos &#125;, del(index)&#123; this.Todos.splice(index,1) &#125;&#125;)export default Store;","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"flux","slug":"flux","permalink":"http://zhaokunming.xyz/tags/flux/"}]},{"title":"web前端性能优化","date":"2018-05-01T08:59:06.000Z","path":"2018/05/01/性能优化/","text":"Web前端性能优化——如何提高页面加载速度 前言： 在同样的网络环境下，两个同样能满足你的需求的网站，一个“Duang”的一下就加载出来了，一个纠结了半天才出来，你会选择哪个？研究表明：用户最满意的打开网页时间是2-5秒，如果等待超过10秒，99%的用户会关闭这个网页。也许这样讲，各位还不会有太多感触，接下来我列举一组数据：Google网站访问速度每慢400ms就导致用户搜索请 求下降0.59%;Amazon每增加100ms网站延迟将导致收入下降1%;雅虎如果有400ms延迟会导致流量下降5-9%。网站的加载速度严重影响了用户体验，也决定了这个网站的生死存亡。 可能有人会说：网站的性能是后端工程师的事情，与前端并无多大关系。我只能说，too young too simple。事实上，只有10%~20%的最终用户响应时间是用在从Web服务器获取HTML文档并传送到浏览器的，那剩余的时间去哪儿了？来瞄一下性能黄金法则： 只有10% ~ 20%的最终用户响应时间花在了下载HTML文档上。其余的80% ~ 90%时间花在了下载页面中的所有组件上。 接下来我们将研究一下前端攻城狮如何来提高页面的加载速度。 一、减少HTTP请求 上面说到80%~90%时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。 图片地图： 假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。 服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应 客户端图片地图：直接将点击映射到操作 12345678&lt;img src=\"planets.jpg\" border=\"0\" usemap=\"#planetmap\" alt=\"Planets\" /&gt;&lt;map name=\"planetmap\" id=\"planetmap\"&gt; &lt;area shape=\"rect\" coords=\"180,139,14\" href =\"venus.html\" alt=\"Venus\" /&gt; &lt;area shape=\"rect\" coords=\"129,161,10\" href =\"mercur.html\" alt=\"Mercury\" /&gt; &lt;area shape=\"rect\" coords=\"0,0,110,260\" href =\"sun.html\" alt=\"Sun\" /&gt; &lt;area shape=\"rect\" coords=\"140,0,110,260\" href =\"star.html\" alt=\"Sun\" /&gt;&lt;/map&gt; 使用图片地图的缺点：指定坐标区域时，矩形或圆形比较容易指定，而其它形状手工指定比较难 CSS Sprites CSS Sprites地址推荐 CSS Sprites直译过来就是CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，然后通过CSS的一些技术布局到网页上。特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。 1234567&lt;div&gt; &lt;span id=\"image1\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image2\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image3\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image4\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image5\" class=\"nav\"&gt;&lt;/span&gt;&lt;/div&gt; 12345678910111213141516171819202122.nav &#123; width: 50px; height: 50px; display: inline-block; border: 1px solid #000; background-image: url('E:/1.png');&#125;#image1 &#123; background-position: 0 0;&#125;#image2 &#123; background-position: -95px 0;&#125;#image3 &#123; background-position: -185px 0;&#125;#image4 &#123; background-position: -275px 0;&#125;#image5 &#123; background-position: -366px -3px;&#125; 运行结果： PS：使用CSS Sprites还有可能降低下载量，可能大家会认为合并后的图片会比分离图片的总和要大，因为还有可能会附加空白区域。实际上，合并后的图片会比分离的图片总和要小，因为它降低了图片自身的开销，譬如颜色表、格式信息等。 字体图标 在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少http请求，字体图标还可以通过CSS来设置颜色、大小等样式，何乐而不为。 合并脚本 和样式表 将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。 然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。 二、使用CDN 如果应用程序web服务器离用户更近，那么一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器离用户更近，则多个HTTP请求的响应时间将缩短。 CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。 CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力。 CDN的缺点： 1、响应时间可能会受到其他网站流量的影响。CDN服务提供商在其所有客户之间共享Web服务器组。2、如果CDN服务质量下降了，那么你的工作质量也将下降3、无法直接控制组件服务器 三、添加Expires头 页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。 Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如： Expires: Fri, 18 Mar 2016 07:41:53 GMT Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查 HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。 Cache-Control： max-age=12345600 若同时制定Cache-Control和Expires，则max-age将覆盖Expires头 四、压缩组件 从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持 Accept-Encoding: gzip,deflate 如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的Content-Encoding来通知 Web客户端。 Content-Encoding: gzip 代理缓存 当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。 解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。 vary: Accept-Encoding 五、将样式表放在头部 首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。 我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。 将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西 六、将脚本放在底部 更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。 js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。 下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。 七、避免CSS表达式 CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。 12345p &#123; width: expression(func(),document.body.clientWidth &gt; 400 ? \"400px\" : \"auto\"); height: 80px; border: 1px solid #f00;&#125; 12345678910111213&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var n = 0; function func() &#123; n++; // alert(); console.log(n); &#125;&lt;/script&gt; 鼠标移动了几次，函数的运行次数轻而易举的达到了几千次，危险性显而易见。 如何解决： 一次性表达式： 12345p &#123; width: expression(func(this)); height: 80px; border: 1px solid #f00;&#125; 12345678910111213&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var n = 0; function func(elem) &#123; n++; elem.style.width = document.body.clientWidth &gt; 400 ? '400px' : \"auto\"; console.log(n); &#125;&lt;/script&gt; 事件处理机制 用js事件处理机制来动态改变元素的样式，使函数运行次数在可控范围之内。 八、使用外部的JavaScript和CSS 内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。 影响因素： 1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。 2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。 加载后下载 有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成止呕动态加载外部组件，以便用户接下来的访问。 12345678910111213141516171819202122232425function doOnload() &#123; setTimeout(\"downloadFile()\",1000); &#125; window.onload = doOnload; function downloadFile() &#123; downloadCss(\"http://abc.com/css/a.css\"); downloadJS(\"http://abc.com/js/a.js\"); &#125; function downloadCss(url) &#123; var ele = document.createElement('link'); ele.rel = \"stylesheet\"; ele.type = \"text/css\"; ele.href = url; document.body.appendChild(ele); &#125; function downloadJS(url) &#123; var ele = document.createElement('script'); ele.src = url; document.body.appendChild(ele); &#125; 在该页面中，JavaScript和CSS被加载两次（内联和外部）。要使其正常工作，必须处理双重定义。将这些组件放到一个不可见的IFrame中是一个比较好的解决方式。 九、减少DNS查找 当我们在浏览器的地址栏输入网址（譬如： www.baidu.com） ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？ 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例： Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有 www.baidu.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问 www.baidu.com 这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问 www.baidu.com 这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道 www.baidu.com 这个域名的IP地址，但是我知道 baidu.com 这个域的DNS地址，你去找它去，于是运营商的DNS又向 baidu.com 这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 www.baidu.com 这个域名的IP地址是多少？），这个时候 baidu.com 域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 www.baidu.com 这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 www.baidu.com 对应的IP地址，该进行一步的动作了。 注：一般情况下是不会进行以下步骤的 如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤：5. 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） 如果第6步也没有查询成功，那么客户端就要进行广播查找 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？ 当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。 减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。 十、精简JavaScript 精简 精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。 混淆 混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。 缺点： 混淆本身比较复杂，可能会引入错误。 需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。 混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。 在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。 CSS的精简 CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。 除了移除空白、注释之外，CSS可以通过优化来获得更多的节省： 合并相同的类； 移除不使用的类； 使用缩写，譬如 1234567891011121314151617181920212223.right &#123; color: #fff; padding-top: 0; margin: 0 10px; border: 1px solid #111&#125;.wrong &#123; color: #ffffff; padding-top: 0px; margin-top: 0; margin-bottom: 0; margin-left: 10px; margin-right: 10px; border-color: #111; border-width: 1px; border-style: solid;&#125; 上面.right是正确的的写法，颜色使用缩写，使用0代替0px，合并可以合并的样式。另外，在精简的时候其实样式最后一行的’；’也是可以省略的。 来看看精简的例子： 以上分别是jquery-2.0.3的学习版（未精简）和精简版，可见精简文件的大小比源文件小了155k，而且，在精简版中jquery还做了混淆，譬如用e代替window等，从而获得最大的节省。 十一、避免重定向 什么是重定向？ 重定向用于将用户从一个URL重新路由到另一个URL。 常用重定向的类型 301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。 302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。 304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。 重定向如何损伤性能? 当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 来看一个实际例子：对于ASP.NET webform开发来说，对于新手很容易犯一个错误，就是把页面的连接写成服务器控件后台代码里，例如用一个Button控件，在它的后台click事件中写上：Response.Redirect(“”)；然而这个Button的作用只是转移URL，这是非常低效的做法，因为点击Button后，先发送一个Post请求给服务器，服务器处理Response.Redirect(“”)后就发送一个302响应给浏览器，浏览器再根据响应的URL发送GET请求。正确的做法应该是在html页面直接使用a标签做链接，这样就避免了多余的post和重定向。 重定向的应用场景 跟踪内部流量 重定向经常用于跟踪用户流量的方向,当拥有一个门户主页的时候，同时想对用户离开主页后的流量进行跟踪，这时可以使用重定向。例如: 某网站主页新闻的链接地址 http://a.com/r/news ，点击该链接将产生301响应，其Location被设置为 http://news.a.com 。通过分析a.com的web服务器日志可以得知人们离开首页之后的去向。 我们知道重定向是如何损伤性能的，为了实现更好的效率，可以使用Referer日志来跟踪内部流量去向。每个HTTP请求都有一个Referer表示原始请求页(除了从书签打开或直接键入URL等操作)，记录下每个请求的Referer，就避免了向用户发送重定向，从而改善了响应时间。 跟踪出站流量 有时链接可能将用户带离你的网站，在这种情况下，使用Referer就不太现实了。 同样也可以使用重定向来解决跟踪出站流量问题。以百度搜索为例，百度通过将每个链接包装到一个302重定向来解决跟踪的问题，例如搜索关键字“前端性能优化”，搜索结果中的一个URL为 https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297 ，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生302重定向，将页面转到目标页面（待修改，求大神们给我指正）） 除了重定向外，我们还可以选择使用信标(beacon)——一个HTTP请求，其URL中包含有跟踪信息。跟踪信息可以从信标Web服务器的访问日记中提取出来，信标通常是一个1px*1px的透明图片，不过204响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。 十二、删除重复脚本 在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多次。 重复的脚本会造成不必要的HTTP请求（如果没有缓存该脚本的话），并且执行多余的JavaScript浪费时间，还有可能造成错误。 如何避免重复脚本呢？ 形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是必要的，所以需要对脚本进行一个良好的组织。 实现脚本管理器模块。 例如： 123456789101112131415161718function insertScript($file) &#123; if(hadInserted($file)) &#123; return; &#125; exeInsert($file); if(hasDependencies($file)) &#123; $deps = getDependencies($file); foreach ($deps as $script) &#123; insertScript($script); &#125; echo \"&lt;script type='text/javascript' src='\".getVersion($file).\"'&gt;&lt;/script&gt;\"; &#125; &#125; 先检查是否插入过，如果插入过则返回。如果该脚本依赖其它脚本，则被依赖的脚本也会被插入。最后脚本被传送到页面，getVersion会检查脚本并返回追加了对应版本号的文件名，这样如果脚本的版本变化了，那么以前浏览器缓存的就会失效。 十三、配置ETag 以前浏览器缓存的就会失效。 什么是ETag？ 实体标签(EntityTag)是唯一标识了一个组件的一个特定版本的字符串，是web服务器用于确认缓存组件的有效性的一种机制，通常可以使用组件的某些属性来构造它。 条件GET请求 如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。 那么服务器是根据什么判断缓存是否还有效呢?有两种方式： ETag（实体标签）； 最新修改日期； 最新修改日期 原始服务器通过Last-Modified响应头来返回组件的最新修改日期。 举个栗子： 当我们不带缓存访问 www.google.com.hk 的时候，我们需要下载google的logo，这时会发送这样一个HTTP请求： Request： GET googlelogo_color_272x92dp.png HTTP 1.1Host: www.google.com.hk Response: HTTP 1.1 200 OKLast-Modified:Fri, 04 Sep 2015 22:33:08 GMT 当需要再次访问相同组件的时候，同时缓存已经过期，浏览器会发送如下条件GET请求： Request： GET googlelogo_color_272x92dp.png HTTP 1.1If-Modified-Since:Fri, 04 Sep 2015 22:33:08 GMTHost: www.google.com.hk Response: HTTP 1.1 304 Not Modified 实体标签 ETag提供了另外一种方式，用于检测浏览器缓存中的组件与原始服务器上的组件是否匹配。摘抄自书上的例子： 不带缓存的请求： Request： GET /i/yahoo/gif HTTP 1.1Host: us.yimg.com Response: HTTP 1.1 200 OKLast-Modified:Tue,12 Dec 200603:03:59 GMTETag:”10c24bc-4ab-457elc1f“ 再次请求相同组件: Request： GET /i/yahoo/gif HTTP 1.1Host: us.yimg.comIf-Modified-Since:Tue,12 Dec 200603:03:59 GMTIf-None-Match:”10c24bc-4ab-457elc1f“ Response: HTTP 1.1 304 Not Midified 为什么要引入ETag? ETag主要是为了解决Last-Modified无法解决的一些问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET; 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒); 某些服务器不能精确的得到文件的最后修改时间。 ETag带来的问题 ETag的问题在于通常使用某些属性来构造它，有些属性对于特定的部署了网站的服务器来说是唯一的。当使用集群服务器的时候，浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求，ETag就会出现不匹配的状况。例如：使用inode-size-timestamp来生成ETag，文件系统使用inode存储文件类型、所有者、组和访问模式等信息，在多台服务器上，就算文件大小、权限、时间戳等都相同，inode也是不同的。 最佳实践 如果使用Last-Modified不会出现任何问题，可以直接移除ETag，google的搜索首页则没有使用ETag。 确定要使用ETag，在配置ETag的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用size-timestamp来生成时间戳。 十四、使Ajax可缓存 维基百科中这样定义Ajax： AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。Ajax的概念由杰西·詹姆士·贾瑞特所提出。 传统的Web应用允许用户端填写表单（form），当提交表单时就向Web服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。 与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。 类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。而客户端与服务器也并不需要异步。一些基于AJAX的“派生／合成”式（derivative/composite）的技术也正在出现，如AFLAX。 Ajax的目地是为突破web本质的开始—停止交互方式，向用户显示一个白屏后重绘整个页面不是一种好的用户体验。 异步与即时 Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。 用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动请求是基于用户当前的操作而发起的 什么样的AJAX请求可以被缓存？ POST的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（可以在服务器端对数据进行缓存，以便提高处理速度） GET的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的AJAX请求，不会重复在服务器执行，而是返回304。 Ajax请求使用缓存 在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度。 十四、减少cookie传输 一方面，cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。 十五、Javascript代码优化 (1). DOM a.HTML Collection（HTML收集器，返回的是一个数组内容信息） 在脚本中 document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合” 包括读取集合的 length属性、访问集合中的元素。 因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。 b. Reflow &amp; Repaint 除了上面一点之外， DOM操作还需要考虑浏览器的Reflow和Repaint ，因为这些都是需要消耗资源的。 (2). 慎用 with with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 (3). 避免使用 eval和 Function 每次 eval 或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。 eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。 Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。 此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。 (4). 减少作用域链查找 前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。 低效率的写法： 123456789&lt;span style=\"font-size:14px;\"&gt;// 全局变量 var globalVar = 1; function myCallback(info)&#123; for( var i = 100000; i--;)&#123; //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 globalVar += i; &#125; &#125; &lt;/span&gt; 更高效的写法： 1234567891011121314&lt;span style=\"font-size:14px;\"&gt;// 全局变量 var globalVar = 1; function myCallback(info)&#123; //局部变量缓存全局变量 var localVar = globalVar; for( var i = 100000; i--;)&#123; //访问局部变量是最快的 localVar += i; &#125; //本例中只需要访问 2次全局变量 在函数中只需要将 globalVar中内容的值赋给localVar 中 globalVar = localVar; &#125; &lt;/span&gt; 此外，要减少作用域链查找还应该减少闭包的使用。 (5). 数据访问 Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量： a. 对任何对象属性的访问超过 1次 b. 对任何数组成员的访问次数超过 1次 另外，还应当尽可能的减少对对象以及数组深度查找。 (6). 字符串拼接 在 Javascript中使用”+”号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。 十六、CSS选择符优化 在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如 #toc A { color: #444; } 这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项。 十七、尽量少用iframe 在写网页的时候，我们可能会用到iframe，iframe的好处是它完全独立于父文档。iframe中包含的JavaScript文件访问其父文档是受限的。例如，来自不同域的iframe不能访问其父文档的Cookie。 开销最高的DOM元素 通常创建iframe元素的开销要比创建其它元素的开销高几十倍甚至几百倍。 iframe阻塞onload事件 通常我们会希望window.onload事件能够尽可能触发，原因如下： 1、我们可能在onload事件处理函数中编写了用于初始化UI的代码；2、onload事件触发时，浏览器停止“忙指示器”，并向用户反馈页面已经准备就绪。3、部分低版本浏览器（IE6、IE7、IE8、Safari3、Safari4、Chrome1、Chrome2等）只有onload事件触发之后才会触发unload事件。有时，我们会把一些重要的操作和window的unload事件绑定在一起。例如，减少内存泄露的代码。如果onload花费时间太长，用户可能会离开页面，那么在这些浏览器中unload可能就永远不会执行了。 通常情况下，iframe中的内容对页面来说不是很重要的（譬如第三方的广告），我们不应该因为这些内容而延迟window.onload事件的触发。 综上，即使iframe是空的，其开销也会很高，而且他会阻塞onload事件。所以，我们应该尽可能避免iframe的使用。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://zhaokunming.xyz/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"withRouter的作用","date":"2018-04-18T12:35:03.000Z","path":"2018/04/18/withRouter的作用和一个简单应用/","text":"withRouter的作用和一个简单应用 作用： 把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 一：如何使用withRouter： 比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下：设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 二：介绍一个简单应用 可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 图片显示不出来，所以我描述一下情况： 点击指定的路由跳转，doument.title属性，即页面标签头的值变为指定title","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"withRouter","slug":"withRouter","permalink":"http://zhaokunming.xyz/tags/withRouter/"},{"name":"title设置","slug":"title设置","permalink":"http://zhaokunming.xyz/tags/title%E8%AE%BE%E7%BD%AE/"}]},{"title":"css3自适应法宝","date":"2018-02-03T04:17:33.000Z","path":"2018/02/03/css3自适应法宝/","text":"css3自适应法宝fill-available、fit-content、max-content、min-content fill-available fill-available表示撑满可用空间（包括高度，宽度），下面举个例子： 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; width: 60%; height: 500px; border: 1px solid #f00; margin: 20px auto 0; &#125; .son&#123; width: -webkit-fill-available; background: #ff0; height:200px;/*高也可以是fill-available*/ &#125; &lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fill-available对于行内块（inline-block）和块元素（block）起作用,这个要注意哦，等高布局就更简单了 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; height: 200px; &#125; .son&#123; width: 30%; height: -webkit-fill-available; background: #f00; display: inline-block; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fit-content fit-content表示宽度缩小到内容的宽度，下面have a 栗子 123456789&lt;style type=\"text/css\"&gt; div&#123; background-color: #f00; width:-webkit-fit-content; &#125;&lt;/style&gt;&lt;div&gt; 师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt; 本来作为块元素的div会继承父级的宽度，然而加fit-content宽度就会缩小到内容宽度,水平居中margin:auto max-content max-conten表示用内部元素宽度值最大的那个元素的宽度作为最终容器的宽度。简单了说就是文字不换行。咱们去吃个栗子就ok了 1234567891011&lt;style type=\"text/css\"&gt; .box&#123; width:-webkit-max-content; &#125; .son&#123; background: #ff0; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt; min-content min-content表示用内部元素最小宽度值最大的那个元素的宽度作为最终容器的宽度。这个最小宽度值有最大什么意思，如果是图片的话最小宽度值就是图片所呈现的宽度，如果是汉字就是一个字的宽度，如果是英文就是单词的宽度，ok了。 123456789101112131415&lt;style&gt; .box&#123; width:-webkit-min-content; border:1px solid pink; &#125; .brother&#123; width: 120px; height: 20px; background: #f00; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"brother\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://zhaokunming.xyz/tags/css3/"},{"name":"自适应","slug":"自适应","permalink":"http://zhaokunming.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94/"}]},{"title":"使用Promise封装简单Ajax方法","date":"2017-12-26T10:47:31.000Z","path":"2017/12/26/使用Promise封装简单Ajax方法/","text":"使用Promise封装简单Ajax方法 在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现： 123456function callback() &#123; console.log('Done');&#125;console.log('before setTimeout()');setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log('after setTimeout()'); 观察上述代码执行，在Chrome的控制台输出可以看到： 1234before setTimeout()after setTimeout()(等待1秒后)Done 可见，异步操作会在将来的某个时间点触发一个函数调用。 AJAX就是典型的异步操作。 GET 1234567891011121314151617181920function getJSON (url) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125; POST 1234567891011121314151617181920function postJSON(url, data) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open(\"POST\", url, true) xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125; 其实Promise就是一个天然的try…catch 1234567getJSON('/api/v1/xxx') // =&gt; 这里面是就try.catch( error =&gt; &#123; // dosomething // =&gt; 这里就是catch到了error，如果处理error以及返还合适的值&#125;).then( value =&gt; &#123; // dosomething // 这里就是final&#125;) 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://zhaokunming.xyz/tags/ajax/"}]},{"title":"cssText的用法","date":"2017-11-08T04:26:26.000Z","path":"2017/11/08/cssText的用法/","text":"cssText的用法以及特点 cssText 本质是什么？ cssText 的本质就是设置 HTML 元素的 style 属性值。 cssText 怎么用？ 1document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\"; cssText 返回值是什么？ 在某些浏览器中（比如 Chrome），你给他赋什么值，它就返回什么值。在 IE 中则比较痛苦，它会格式化输出、会把属性大写、会改变属性顺序、会去掉最后一个分号，比如： 123document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\";alert(document.getElementById(\"d1\").style.cssText); 在 IE 中值为：FONT-SIZE: 13px; COLOR: red cssText的使用优势 一般情况下我们用js设置元素对象的样式会使用这样的形式： 1234var element= document.getElementById(\"id\"); element.style.width=\"20px\"; element.style.height=\"20px\"; element.style.border=\"solid 1px red\"; 样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。 js中有一个cssText的方法： 语法为： 123obj.style.cssText=\"样式\";element.style.cssText=\"width:20px;height:20px;border:solid 1px red;\"; 这样就可以尽量避免页面reflow，提高页面性能。 但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。 为了解决这个问题，可以采用cssText累加的方法： 1Element.style.cssText += \"width:100px;height:100px;top:100px;left:100px;\" 因此，上面cssText累加的方法在IE中是无效的。 最后，可以在前面添加一个分号来解决这个问题： 1Element.style.cssText += \";width:100px;height:100px;top:100px;left:100px;\" 再进一步，如果前面有样式表文件写着 1div &#123; text-decoration:underline; &#125; 这个会被覆盖吗？不会！因为它不是直接作用于 HTML 元素的 style 属性。 具体案例分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;控制div属性&lt;/title&gt;&lt;style&gt;#outer&#123;width:500px;margin:0 auto;padding:0;text-align:center;&#125;#div1&#123;width:100px;height:100px;background:black;margin:10px auto;display:block;&#125;&lt;/style&gt;&lt;script&gt;var changeStyle = function (elem, attr, value)&#123; elem.style[attr] = value&#125;;window.onload = function ()&#123; var oBtn = document.getElementsByTagName(\"input\"); var oDiv = document.getElementById(\"div1\"); var oAtt = [\"width\",\"height\",\"background\",\"display\",\"display\"]; var oVal = [\"200px\",\"200px\",\"red\",\"none\",\"block\"]; for (var i = 0; i &lt; oBtn.length; i++) &#123; oBtn[i].index = i; oBtn[i].onclick = function () &#123; this.index == oBtn.length - 1 &amp;&amp; (oDiv.style.cssText = \"\"); changeStyle(oDiv, oAtt[this.index], oVal[this.index]) &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"outer\"&gt;&lt;input type=\"button\" value=\"变宽\" /&gt;&lt;input type=\"button\" value=\"变高\" /&gt;&lt;input type=\"button\" value=\"变色\" /&gt;&lt;input type=\"button\" value=\"隐藏\" /&gt;&lt;input type=\"button\" value=\"重置\" /&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"html","slug":"html","permalink":"http://zhaokunming.xyz/tags/html/"},{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"css","slug":"css","permalink":"http://zhaokunming.xyz/tags/css/"}]},{"title":"vuex的语法糖","date":"2017-09-30T02:18:56.000Z","path":"2017/09/30/vuex的语法糖/","text":"vuex的语法糖-辅助函数mapState , mapMutations , mapActions , mapGetters vuex五大核心 State Getters Mutations Actions Module 我们项目中需要的都是：state、getters、mutations、actions里面的东西调用方法和使用的位置也是有区别的不过vuex给我们提供了辅助函数：mapState , mapMutations , mapActions , mapGetters 调用 方法 辅助函数 state this.$store.state.xxx mapState getters this.$store.getters.xxx mapGetters mutations this.$store.commit(xxx) mapMutations actions this.$store.dispatch(xxx) mapActions 注意mapState和mapGetter的使用只能在computed计算属性中，mapMutations和mapActions使用的时候只能在methods中调用否则报错 如何实际使用辅助函数？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script&gt;import &#123; mapState , mapMutations , mapActions , mapGetters &#125; from 'vuex';export default &#123; data()&#123; return&#123; &#125; &#125;, computed:&#123; ...mapState(&#123; counts:(state) =&gt; state.count &#125;), //mapState就等于下面这个 // counts()&#123; // return this.$store.state.count // &#125;, ...mapGetters(&#123; getternum:'doneTodos' &#125;), //mapGetters就等于下面的这个 // getternum()&#123; // return this.$store.getters.doneTodos // &#125; &#125;, methods:&#123; ...mapMutations(&#123; addnum:'addNum' &#125;), addnum1()&#123; this.addnum() &#125;, //mapMutations就等于下面的这个 // addnum1()&#123; // this.$store.commit('addNum') // &#125;, ...mapActions(&#123; actionnum:'actionNumAdd' &#125;), actionnum6()&#123; this.actionnum() &#125;, //mapActions就等于下面的这个 // actionnum6()&#123; // this.$store.dispatch('actionNumAdd') // &#125; &#125;&#125;&lt;/script&gt; 辅助函数总结 当项目场景中我们需要大量的调用state中的值和触发多个actions的时候，我们还得写大量重复的代码，这时候辅助函数的作用就体现出来了，其实就是vuex的一个语法糖，使代码更简洁更优雅。","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"},{"name":"vuex语法糖","slug":"vuex语法糖","permalink":"http://zhaokunming.xyz/tags/vuex%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"name":"vue辅助函数","slug":"vue辅助函数","permalink":"http://zhaokunming.xyz/tags/vue%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"}]},{"title":"图片懒加载","date":"2017-08-11T01:12:46.000Z","path":"2017/08/11/图片懒加载/","text":"前端实现图片懒加载（lazyload）的两种方式 在实际的项目开发中，我们通常会遇见这样的场景：一个页面有很多图片，而首屏出现的图片大概就一两张，那么我们还要一次性把所有图片都加载出来吗？显然这是愚蠢的，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，技术上现实其中要用的技术就是图片懒加载–到可视区域再加载。 思路： 将页面里所有img属性src属性用data-xx代替，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。也就是说，我们在开始先加载一张图片，这张图片作为所有img的初始src属性，加载一张图片的速度肯定会比加载十张图片的速度快，当我们需要看到img真正要展示的效果时，即出现在用户的可视区域内时，我们在即将进入用户可视区域的时候将img的src属性替换为真实路径，从而实现懒加载。 这就需要监听scroll属性了 关于各种宽高： 12345678910111213页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 示例：jqueryLazyload方式 下载地址：https://github.com/helijun/helijun/blob/master/plugin/lazyLoad/jquery.lazyload.js 123&lt;section class=\"module-section\" id=\"container\"&gt; &lt;img class=\"lazy-load\" data-original=\"../static/img/loveLetter/teacher/teacher1.jpg\" width=\"640\" height=\"480\" alt=\"测试懒加载图片\"/&gt;&lt;/section&gt; 12345678910111213require.config(&#123; baseUrl : \"/static\", paths: &#123; jquery:'component/jquery/jquery-3.1.0.min' jqueryLazyload: 'component/lazyLoad/jquery.lazyload',//图片懒加载 &#125;, shim: &#123; jqueryLazyload: &#123; deps: ['jquery'], exports: '$' &#125; &#125;&#125;); 12345678910111213141516require( [ 'jquery', 'jqueryLazyload' ], function($)&#123; $(document).ready(function() &#123; $(\"img.lazy-load\").lazyload(&#123; effect : \"fadeIn\", //渐现，show(直接显示),fadeIn(淡入),slideDown(下拉) threshold : 180, //预加载，在图片距离屏幕180px时提前载入 event: 'click', // 事件触发时才加载，click(点击),mouseover(鼠标划过),sporty(运动的),默认为scroll（滑动） container: $(\"#container\"), // 指定对某容器中的图片实现效果 failure_limit：2 //加载2张可见区域外的图片,lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况 &#125;); &#125;); &#125;); 为了代码可读性，属性值我都写好了注释。值得注意的是预制图片属性为data-original，并且最好是给予初始高宽占位，以免影响布局，当然这里为了演示我是写死的640x480，如果是响应式页面，高宽需要动态计算。 或者使用纯jquery 123456&lt;style&gt; img&#123; width: 300px; height: 300px; &#125;&lt;/style&gt;//这里给所有图片一个固定大小，为了美观 12345678910&lt;body&gt; &lt;ul&gt;//这里给几张图片简单模拟效果 &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060304326.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060308503.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602395423.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602573572.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603021166.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603062432.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt; let imgs=document.querySelectorAll('img') loadImg(imgs) window.onscroll=function()&#123; loadImg(imgs) &#125; function loadImg(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; if(arr[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight &amp;&amp; !arr[i].isLoad)&#123; arr[i].isLoad = true; // arr[i].style.cssText=\"opacity:0.3\" setTimeout(function()&#123; arr[i].style.cssText='opacity:1;transition:3s;' &#125;,500) aftImg(arr[i],arr[i].getAttribute('data')) &#125; &#125; &#125; function aftImg(obj,url)&#123; var Img=new Image() Img.onload=function()&#123; obj.src=Img.src &#125; Img.src=url; &#125;&lt;/script&gt; echo.js方式 介绍了一款非常简单实用轻量级的图片延时加载插件echo.js，如果你的项目中没有依赖jquery，那么这将是个不错的选择，50行代码，压缩后才1k。当然你完全可以集成到自己项目中去！ 下载地址：https://github.com/helijun/helijun/tree/master/plugin/echo 123456&lt;style&gt; .demo img &#123; width: 736px; height: 490px; background: url(images/loading.gif) 50% no-repeat;&#125;&lt;/style&gt; 123&lt;div class=\"demo\"&gt; &lt;img class=\"lazy\" src=\"images/blank.gif\" data-echo=\"images/big-1.jpg\"&gt;&lt;/div&gt; 12345678910&lt;script src=\"js/echo.min.js\"&gt;&lt;/script&gt;&lt;script&gt;Echo.init(&#123; offset: 0,//离可视区域多少像素的图片可以被加载 throttle: 0 //图片延时多少毫秒加载&#125;); &lt;/script&gt; 说明：blank.gif是一张背景图片，包含在插件里了。图片的宽高必须设定，当然，可以使用外部样式对多张图片统一控制大小。data-echo指向的是真正的图片地址。","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhaokunming.xyz/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"总要写点什么","date":"2017-07-14T01:25:57.000Z","path":"2017/07/14/start/","text":"本博开博文章，以祭奠流逝的时间 今天是个好日子，在经历了无数的挫折之后，我终于也是拥有了一个自己的博客网站。 仿佛每个人都要写一下开博文章，我也就写一下吧，一方面是为了记录我搭建博客的心酸，另一方面也回忆一下过去，展望一下未来。 怎么萌生一个搭建个人博客的念头的呢？这个没有确切的起点，起初我的笔记，工作经验什么的都写在了印象笔记里面，也就是记录一下生活，工作的问题，但大多只是记录，没有太多的思考。而管理个人博客就要花更多的时间去管理、维护，更多的这是属于自己的小空间。同时，我看到网站上的博客越来越多，而且也很方便，可以和更多的技术大牛沟通，交流技术。这样看来，搭建个人博客还是很有必要的（我是这样说服自己的）。 搭建之路很漫长，本来可以一两天搞定的事情，我花了一个多星期。原因，主要是我的环境坏掉了。好像hexo都有一个弊端吧，就是init只能一个，再多就会报错。不可修复的那种，最重要的是不要把第一次init的文件删了。我就是死在的这一步。当时请教了一些人，没有解决，还衍生出了其他的错误。环境坏了能怎么办，心灰意冷只能换电脑。不过好在成功搭建，于是才有了它。这还是一个看脸的时代，好的皮肤可能比操作还要重要，所以，又花费时间找了个还不错的主题。这里问题就不再详述了。总之，它就这样走进我的生活当中。过程很残忍，却被成功的喜悦覆盖了。 现在看来，搭建博客很简单吗，，，对。不过，有句话说，坚持难，例子，就是苏格拉底的例子。要持续更新博客，这可是个技术活。思考，这是必不可少的，同时，博客可能不止自己看，所，应该让大多数的人看懂，这很重要。多长时间更一篇，这个，还没想好，不过，要有时间，要坚持，坚持就是胜利。 这里引进胡伟煌的一段话：“花费了这么多时间和精力，对我个人来说是否有什么影响，应该是说找到了一种比较笨的学习方式。写博客是很耗时间的，需要将你学习到的东西通过自己认为比较简练的语言归纳整理，并且有条理或系统地去让别人更容易读懂，在这过程中自己的总结归纳能力等可以得到锻炼，而有的知识你以为懂了，当要写出来的时候会发现好像还没懂，这时候也可以再去思考这个知识。当形成了自己的知识体系后，即时你哪天忘记了你写的内容，也可以很快的找到答案所在的地方。就好比开卷考试，当你记不住答案或者也不一定要记住答案是什么，只需要知道在哪里可以快速找到答案就够了。如果可以快速有效地解决问题，也不一定要关心你是怎么解决的。当你学的东西越来越多，你会发现你不懂的也越来越多，好比一个圆，圆内的面积越大，圆外接触的不懂的东西也越多。” 第一：生活 搭建博客的初衷，是沉淀一些自己知识、技能的记录。我对技术非常好奇，不断去尝试，各种摸索、各种分析。生活不仅仅只是上班下班，在上班的过程里面，还有那么一些尝试，让我尝试完，积累知识，然后好好沉淀下。 我一直都是一个很懂得“接受”的人，为什么说是接受呢？因为我觉得，我在生活中经历过的大大小小的各种事情，都是对自己的考验，按照市面上的一句话来说，就是感恩苦难。当然苦难本身是不值得感恩的，胡歌在采访中说，苦难本身是不值得感恩的，苦难带来的伤痛是无法抹去的。我真正要感谢的是自己在经历了各种事情之后所积累的经验与能力。所以说，我在碰到困难的时候第一想的不是放弃，而是尝试解决，就比如我在编程过程中，解决问题的最好方法是解决问题本身，而不是换条路达到解决问题的目的。当然，二者兼得更好。 或者现实一点的说法就是，我在不断增强自己的实力。活到老，学到老。我希望我的一生能够贯彻这一点。 第二：未来 毕业有一段时间了，工作暂时找好了，工作失误免不了被老板骂，一直没有离职。一方面，确实是自己做错了，无可厚非，错了就是错了，我也在积累项目错误的经验，为了以后再次碰到这种情况能快速解决。一方面，我觉得没必要记恨别人，人的一生也不过是白驹过隙，能让人生更有意义一些才会在闭上眼睛回望一生时嘴角上扬。而且，老板也不坏，人之初，性本善，当然也可能是我还没碰到所以才说出这样的话。这里，我要感谢我老板在我工作方面的照顾，批评我的错误是正常的，体谅员工的老板才是好老板，巧的是，我的老板就是这样的人。 对未来的规划，小时候，在电视上看职场情景，有赶地铁的人，拿着早餐路上吃的上班族，早上赶电梯，晚上外套一脱，躺床上。好像生活很单一，又很无聊。如今看来，似乎生活还有很多乐趣。工作也不是如僵尸一样低头看文档。现在，首先是挣钱吧，最主要的是养活自己，不至于看到有人帮助的时候一掏腰包两手空，然后努力工作，给父母更好的生活，闲暇时间还可以旅旅游，放松一下。然后感叹，这就是生活鸭。 未来可期！ 第三：时间 时间是个好东西，只喜多不喜少。 就比如，这篇博客吧，本来打算二十分钟写完的，结果，边想边写，就花费了四十多分钟。 最近遇到一些事情，逼迫自己去思考工作、生活的意义。才发现工作是忙了，但是得到的除了钱，好像什么都没有。 精神还是空虚着，能力还是没怎么提高，未来10年、20年，靠什么继续下去？ 开一个博客，对人生的一种坚持与新生，在未来，尝试不一样的事情，对生活，充满着期待！","tags":[{"name":"生活","slug":"生活","permalink":"http://zhaokunming.xyz/tags/%E7%94%9F%E6%B4%BB/"},{"name":"start","slug":"start","permalink":"http://zhaokunming.xyz/tags/start/"}]}]