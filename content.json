[{"title":"记一次春运","date":"2020-01-10T02:10:57.000Z","path":"2020/01/10/记一次春运/","text":"当时离过年还有两个多星期，但郑州有点事，就不得不请个假回趟郑州。 买的火车票，夜车，因为是提前很多天买的，所幸的是抢到了票。 从到火车站再到上车没花什么精力，车站中弥漫这泡面的味道以及熬了几夜一动不动而产生的气味。在进入车厢的时候排了很长时间的队，当时在外面没想通为什么，以为是查票，直到进入车厢后才发现是站着的人们堵塞了路口。终于是挤到了自己的座位，那是在过道旁边的位置。 我的旁边站着一对中年夫妇，还有一两个年轻人。这个时间点坐车的基本上都是回家的，带着的行李肯定也不会少。大行李箱有很多，回家很累的原因之一。很挤，简单来说就是放脚的地方只有那么大，动一下可能就碰到了别人。列车终于是开动，买站票的人也是松了一口气，可以稍微休息一下。但事实好像没那么简单，各种时间点中来回上厕所的和接水的人络绎不绝，接热水泡面的人更是人来人往。泡面的味道很快就在空气中扩散开了。 最难熬的不是刚上车的时候，因为人们大都充满了精力，幻想着可以一直撑到下车。于是刚上车这段时间过的很快。真正难熬的时分即将到来……上车时间大概是五点二十，而现在的时间点是夜里十点钟。终于在人来人往、推推攘攘的人群中失去精力，困意开始冲击大脑神经，眼皮开始打起了打烊的念头，趁人不注意的将窗帘拉下来。买站票的人们迎来了最具挑战的时刻。他们没有落脚之处，想休息一下的话好像只能靠着车门或者靠着座椅边上，看，那个人找到了一个巧妙又温柔的姿势，可以让他小憩一会儿。我真应该为他高兴，可我知道，“暴风雨”马上就要来了。这时未见其人先闻其声的列车推销员到了，“来让一让，过一下。。。”，推着小推车的这种列车推销员最难伺候，因为他们不是一个人，而是两个，车在人在。人过去简单，车过去嘛，就要花大力气了。行李，抬一下吧。人，往旁边挤挤吧。“你不愿意挪，我帮你挪”，所以说迄今为止我还没见到有哪个推销员连车厢都过不去的。诶，你可别松气啊，这只是“车头”，后面还有卖水果皮带的呢。我不知道这场推销狂欢是什么时候结束的，反正途中还有接水、上厕所的人，熙熙攘攘的人群我闭上眼睛就看不到，但买站票的人能不能闭上眼就不知道了。大概是十一点结束的吧，也可能是我记错了，我那时候睡着了，狂欢可能还在继续。 我的座位在走廊旁边，没有桌子可以支撑一下。我只能将头靠在座椅上，跟着列车左右摇摆。深度睡眠是不大可能，一次能睡多长时间还得看天意，醒了，看一眼走廊上的人们，看一眼时间。啊，时间过的可真慢呀。 大概是后半夜，我被冻醒了，看了一眼车票，是空调车厢没错，现在是冬天，可怎么一小会吹热风一小会吹凉风呢？又看了一眼走廊上的人们，东倒西歪的已经睡着了，舒不舒服就不管了。 早上六七点，或者更早，列车推销员开始工作，叫醒睡着的，或者没睡着的人们。推销东西才是重中之重，一声老乡老乡的叫着，我管你们？ 买车票的时候看了一下时间，十四个小时。这要是我买的站票，我该怎么熬过来呢？ 我听一个人说：现在已经不是回不了家的时代了。话虽然没错，可实际上回家难的问题还在继续发生。春运这个问题以及持续了很多年，年年都在解决，可是年年都没有解决。火车、汽车、高铁、飞机……交通方式确实很多，可是能给老百姓用的却不多。火车可以说最便宜。汽车高一倍，高铁高两倍。这就不说了，外出打工的大多是农民工，哪是月薪过万的高领。回趟家都得斟酌再三，而大多数人都是中年偏下，对于智能机这个概念并不是说不知道，只能说不清楚，知道抢票的人更在少数。能真真正正买到坐票的又有多少人呢。回家站个十来个小时的车恐怕是再正常不过了。那是不是挤到同一天了呢？春运票发售恐怕还没有五天就已经没了，买站票是必然的。大不了多出一倍买汽车票？辛苦一天挣一百跟辛苦一天站着回家哪个划算，那一百块钱给孩子买点衣服难道不好吗？ 好了，不瞎说什么了","tags":[{"name":"生活","slug":"生活","permalink":"http://zhaokunming.xyz/tags/%E7%94%9F%E6%B4%BB/"},{"name":"随笔","slug":"随笔","permalink":"http://zhaokunming.xyz/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"简单理解vue中的nextTick","date":"2019-10-05T01:36:44.000Z","path":"2019/10/05/简单理解vue中的nextTick/","text":"转自：https://www.jianshu.com/p/a7550c0e164f Vue中的nextTick涉及到Vue中DOM的异步更新 一、示例先来一个示例了解下关于Vue中的DOM更新以及nextTick的作用。 模板 123456789&lt;div class=\"app\"&gt; &lt;div ref=\"msgDiv\"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg1\"&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg2\"&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;div v-if=\"msg3\"&gt;Message got outside $nextTick: &#123;&#123;msg3&#125;&#125;&lt;/div&gt; &lt;button @click=\"changeMsg\"&gt; Change the Message &lt;/button&gt;&lt;/div&gt; Vue实例 12345678910111213141516171819new Vue(&#123; el: '.app', data: &#123; msg: 'Hello Vue.', msg1: '', msg2: '', msg3: '' &#125;, methods: &#123; changeMsg() &#123; this.msg = \"Hello world.\" this.msg1 = this.$refs.msgDiv.innerHTML this.$nextTick(() =&gt; &#123; this.msg2 = this.$refs.msgDiv.innerHTML &#125;) this.msg3 = this.$refs.msgDiv.innerHTML &#125; &#125;&#125;) 点击前 点击后 从图中可以得知：msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的（详细解释在后面）。 二、应用场景下面了解下nextTick的主要应用的场景及原因。 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中 在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题。 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 具体原因在Vue的官方文档中详细解释： Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。 例如，当你设置vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 三、nextTick源码浅析作用 Vue.nextTick用于延迟执行一段代码，它接受2个参数（回调函数和执行回调函数的上下文环境），如果没有提供回调函数，那么将返回promise对象。 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * Defer a task to execute it asynchronously. */export const nextTick = (function () &#123; const callbacks = [] let pending = false let timerFunc function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; &#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; &#125; else &#123; // fallback to setTimeout /* istanbul ignore next */ timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) &#125; &#125; return function queueNextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve = resolve &#125;) &#125; &#125;&#125;)() 首先，先了解nextTick中定义的三个重要变量。 callbacks 用来存储所有需要执行的回调函数 pending 用来标志是否正在执行回调函数 timerFunc 用来触发执行回调函数 接下来，了解nextTickHandler()函数。 12345678function nextTickHandler () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; 这个函数用来执行callbacks里存储的所有回调函数。 接下来是将触发方式赋值给timerFunc。 先判断是否原生支持promise，如果支持，则利用promise来触发执行回调函数； 否则，如果支持MutationObserver，则实例化一个观察者对象，观察文本节点发生变化时，触发执行所有回调函数。 如果都不支持，则利用setTimeout设置延时为0。 最后是queueNextTick函数。因为nextTick是一个即时函数，所以queueNextTick函数是返回的函数，接受用户传入的参数，用来往callbacks里存入回调函数。 上图是整个执行流程，关键在于timeFunc()，该函数起到延迟执行的作用。 从上面的介绍，可以得知timeFunc()一共有三种实现方式。 Promise MutationObserver setTimeout 其中Promise和setTimeout很好理解，是一个异步任务，会在同步任务以及更新DOM的异步任务之后回调具体函数。 下面着重介绍一下MutationObserver。 MutationObserver是HTML5中的新API，是个用来监视DOM变动的接口。他能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。调用过程很简单，但是有点不太寻常：你需要先给他绑回调： 1var mo = new MutationObserver(callback) 通过给MutationObserver的构造函数传入一个回调，能得到一个MutationObserver实例，这个回调就会在MutationObserver实例监听到变动时触发。 这个时候你只是给MutationObserver实例绑定好了回调，他具体监听哪个DOM、监听节点删除还是监听属性修改，还没有设置。而调用他的observer方法就可以完成这一步: 1234var domTarget = 你想要监听的dom节点mo.observe(domTarget, &#123; characterData: true //说明监听文本内容的修改。&#125;) 在nextTick中 MutationObserver的作用就如上图所示。在监听到DOM更新后，调用回调函数。 其实使用 MutationObserver的原因就是 nextTick想要一个异步API，用来在当前的同步代码执行完毕后，执行我想执行的异步回调，包括Promise和 setTimeout都是基于这个原因。","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"}]},{"title":"vue中slot插槽的使用","date":"2019-09-11T03:11:24.000Z","path":"2019/09/11/vue中slot插槽的使用/","text":"slot 插槽 ，是用在组件中，向组件分发内容。 它的内容可以包含任何模板代码，包括HTML。 vue在2.6.0中，具名插槽和作用域插槽引入了一个新的统一的语法(即v-slot指令)。它取代了slot和slot-scope这两个目前已被废弃但未被移除且仍有用的特性。但是将会在vue3中，被废弃的这两个，不会被支持即无效。 在2.6.0之前，插槽的用法： 1. 匿名插槽。 以 .vue 这种单文件模块为例 1234567891011121314151617181920//创建 testSlot.vue组件&lt;template&gt; &lt;div&gt; //slot里面也可以设置内容，这个可以设置不传内容时，slot有个默认值替换 &lt;slot&gt;这里面是slot的默认值&lt;/slot&gt; &lt;h3&gt;slot组件页面&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:[], data:function()&#123; return &#123;&#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 12345678910111213141516171819202122232425//引用testSlot组件&lt;template&gt; &lt;div&gt; &lt;h1&gt;引用testSlot组件的页面&lt;/h1&gt; &lt;testSlot&gt; &#123;&#123;msg&#125;&#125; &lt;/testSlot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import testSlot from '../components/testSlot' export default&#123; data () &#123; return &#123; msg:'这是动态传入的slot的内容' &#125; &#125;, components:&#123; testSlot &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 结果： 注意事项： 1） 匿名的方式，就是指把在引用组件的时候，里面传的内容，全部一起传送到组件页面中 slot 所在的位置。 2） 只要组件中有 slot ，并且不管有多少个，都会全部渲染为传过来的内容。 3） slot 里面也可以设置内容，这个内容是保证引入组件的时候，有个默认值。当然，slot 里面不设置内容也可以，这样只是没有默认值，是不会报错的。 4） 传递的内容，也可以是动态的，如同上面一样。但是要注意的是，这个内容不能是 引用组件的时候组件上的内容，要注意作用域。可以查看官网 插槽编译作用域。 5） 如果传递的内容，没有 slot 来接收，那么，传递的内容就会被抛弃掉，不会起作用。 2. 具名插槽，就是给插槽指定名称，然后一 一对应 123456789101112131415161718//引入组件的页面&lt;testSlot&gt; &lt;template slot='header'&gt; &lt;p&gt;------------header----------------&lt;/p&gt; &lt;h3&gt;这是header1的内容&lt;/h3&gt; &lt;p&gt;这是header2的内容&lt;/p&gt; &lt;/template&gt; &lt;template slot='footer'&gt; &lt;p&gt;------------footer----------------&lt;/p&gt; &lt;h3&gt;这是footer1的内容&lt;/h3&gt; &lt;p&gt;这是footer2的内容&lt;/p&gt; &lt;/template&gt; &lt;p&gt;-----------default-----------------&lt;/p&gt; &lt;p&gt;这是default剩下的内容1&lt;/p&gt; &lt;p&gt;这是default剩下的内容2&lt;/p&gt;&lt;/testSlot&gt; 12345//组件当前页面&lt;slot&gt;---默认内容---&lt;/slot&gt;&lt;h3&gt;slot组件页面&lt;/h3&gt;&lt;slot name='header'&gt;---header的默认内容---&lt;/slot&gt;&lt;slot name='footer'&gt;---footer的默认内容---&lt;/slot&gt; 结果： 注意事项： 1） 引入组件的页面，如果是多个内容，需要用template 包裹起来，并且添加 slot 属性和 自定义值 。 2） slot 的值 需要和 组件中 “slot name=’xxx’” name的值相对应。 3） 如果剩下的内容没有包裹起来并制定值的话，那么这些内容会被渲染到 组件中 所有的 slot 所在的位置。 4） 如果 slot 设置为default 和 name 设置为default，那就和没设置slot与name是一样的。 5） 和vue 2.6.0 以后的具名插槽相比 template上的 slot=’xxx’ 只需要 改成 v-slot : xxx 就行了，等号改成了冒号，并且值没有引号，带引号反而会报错。 6） 具名插槽只需要 name值 与 slot的值 对应 ，和插槽的顺序没有关系。 3. slot-scope 作用域插槽。 这个的作用，主要就是当向组件发送的内容需要和组件的props属性的内容有联系时，才使用这个作用域插槽。简单点来说就是：可以使用 子组件的数据 和 父组件传过来的props的值。 123456789101112131415161718192021222324252627282930//引入组件的页面&lt;template&gt; &lt;div&gt; &lt;!--这里向组件传入props--&gt; &lt;slotScope :message='msg'&gt; &lt;!--这里的thing是随便取的名称，不与任何地方对应--&gt; &lt;div slot='sayWhat' slot-scope='thing'&gt;说了：&#123;&#123;thing.said&#125;&#125;&lt;/div&gt; &lt;!--这里的val也是随便取的名称，不与任何地方对应--&gt; &lt;template slot='listbox' slot-scope='val'&gt; &lt;p&gt;&#123;&#123;val.send.text&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;/slotScope&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import slotScope from '../components/slotScope' export default&#123; data () &#123; return &#123; msg: '这是动态传入的slot的内容', &#125; &#125;, components:&#123;slotScope &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839//组件页面&lt;template&gt; &lt;div&gt; &lt;!--这里最重要的是 :send=value，send也是可以随便取的，表示要传过去的值--&gt; &lt;slot name='listbox' v-for='value in list' :send='value'&gt;&lt;/slot&gt; &lt;!--这里最重要的是 :said='message'，said也是可以随便取的，表示要传过去的值--&gt; &lt;slot name='sayWhat' :said='message'&gt;&lt;/slot&gt; &lt;ul&gt; &lt;li v-for='item in list' :key='item.id'&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props:['message'], data:function()&#123; return &#123; list:[&#123; \"id\":10, \"text\":\"苹果\" &#125;,&#123; \"id\":20, \"text\":\"香蕉\" &#125;,&#123; \"id\":30, \"text\":\"梨\" &#125;,&#123; \"id\":40, \"text\":\"芒果\" &#125;] &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 结果： 注意事项： 1） 作用域插槽主要是 使用子组件的任何数据 来达到自定义显示内容的目的 2） 作用域插槽最最最最最重要的一步，即是在 1&lt;slot&gt;&lt;/slot&gt; 上绑定数据 ，如果没有绑定数据，则父组件收到的，只是一个空对象{ }。 3） 作用域插槽中 1&lt;slot&gt;&lt;/slot&gt; 上绑定数据，可以是写死的，也可以是动态绑定的。如果是动态绑定的，则也需要 v-bind:xxx 4） 作用域插槽中 1&lt;slot&gt;&lt;/slot&gt; 上绑定的数据 也可以传一个定义好的有返回值的 mthods 方法。比如我定义了 1&lt;slot what='say()'&gt;&lt;/slot&gt;，然后say方法为： say:function(){ return ‘我说了’ } 。最后得到的结果就是 “我说了”，当然，动态绑定一定要加 v-bind:xxx。 5） 当 绑定上数据之后，引用组件的地方 中 发送的内容就能通过 slot-scope 来获取。获取到的内容，就是一个对象，比如 1&lt;slot name='sayWhat' said='message'&gt;&lt;/slot&gt; 我这里绑定 said=’message’ 之后， 那边接收到的就是 { said:”xxxx”} 一个对象。 6） slot-scope 可以接收任何有效的可以出现在函数定义的参数位置上的 JavaScript 表达式 vue 2.6.0之后 v-slot 只能用在 组件component 或者 template 上 ，用在 div 或 p 这种标签上是会报错的 1. 具名插槽的变化 12345678910111213141516&lt;testSlot&gt; &lt;!--2.6.0以前的写法--&gt; &lt;template slot='header'&gt; &lt;p&gt;------------header----------------&lt;/p&gt; &lt;h3&gt;这是header1的内容&lt;/h3&gt; &lt;p&gt;这是header2的内容&lt;/p&gt; &lt;/template&gt; &lt;!--2.6.0之后的写法--&gt; &lt;template v-slot:header&gt; &lt;p&gt;------------header----------------&lt;/p&gt; &lt;h3&gt;这是header1的内容&lt;/h3&gt; &lt;p&gt;这是header2的内容&lt;/p&gt; &lt;/template&gt;&lt;/testSlot&gt; 1） slot=’ xxx ‘ 改成了 v-slot : xxx 并且冒号后面这个名称不能打引号 2） 组件页面中slot的内容没有变化 3） 2.6.0 之后 具名插槽 v-slot:header 可以缩写为 #header ，必须是有参数才能这样写！！！ # = “xxx “ 这样是不行的 #default = ‘xxx’ 这样才可以 2. 作用域插槽的变化 12345678910111213141516&lt;slotScope :message='msg'&gt; &lt;!--2.6.0之前的写法--&gt; &lt;div slot='sayWhat' slot-scope='thing'&gt;说了：&#123;&#123;thing.said&#125;&#125;&lt;/div&gt; &lt;template slot='listbox' slot-scope='value'&gt; &lt;p&gt;&#123;&#123;value.send.text&#125;&#125;&lt;/p&gt; &lt;/template&gt; &lt;!--2.6.0之前的写法，不能单独用在html标签上--&gt; &lt;template v-slot:sayWhat='thing'&gt; &lt;div&gt;说了：&#123;&#123;thing.said&#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:listbox='value'&gt; &lt;p&gt;&#123;&#123;value.send.text&#125;&#125;&lt;/p&gt; &lt;/template&gt;&lt;/slotScope&gt; 1） 两个属性合并成了一个 v-slot : 插槽名称 = ‘ 传过来的值 ‘ 。 2） 组件页面中slot的内容没有变化 。 3） v-slot 不能用在 html 标签上 。 4） 如果是默认插槽 可以写成 v-slot=’xxx’。 5） 还增加了 可以解构插槽props 和 设置默认值的内容，具体的可以查看官网 解构插槽 3. 新增的还有 动态插槽名 什么是动态插槽名？大致就是动态指令参数也可以用在v-slot上，这个就要涉及到2.6.0新增的 动态参数 123&lt;template v-slot:[attrContent]='msg'&gt; xxx&lt;/template&gt; 这个 attrContent 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。 比如这里attrContent 最终的值为 default 则渲染出来的结果 就是 v-slot:default=‘msg’ 。 注意： 1） 单独在 [ ] 方括号中也可以使用表达式，但是不能存在引号和空格 2） 当然 这个动态的值 可以通过 方法，计算属性，或者 data数据 里面的内容。重要的是这个动态的值 是 引用组件的 作用域。简单点说就是父级组件的作用域。 例如，上面 v-slot:sayWhat=’thing’ 可以写成： 1） v-slot:[first+sec]=’thing’ 注意 加号两边不能留空格 2） v-slot:[attr]=’thing’ 3） v-slot:[attrs]=’thing’ 4） v-slot:[getattr()]=’thing’ 123456789101112131415161718192021export default&#123; data () &#123; return &#123; msg: '这是动态传入的slot的内容', attr:'sayWhat', first:'say', sec:'What', &#125; &#125;, components:&#123; slotScope &#125;, computed:&#123; attrs:function()&#123; return 'sayWhat' &#125; &#125;, methods:&#123; getattr()&#123; return 'sayWhat' &#125; &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"},{"name":"slot","slug":"slot","permalink":"http://zhaokunming.xyz/tags/slot/"}]},{"title":"el-table与el-form同用及校验","date":"2019-07-29T12:42:23.000Z","path":"2019/07/29/el-table与el-form同用及校验/","text":"转自：https://blog.csdn.net/qq_31126175/article/details/97265338 基本结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;el-form ref=\"form\" :model=\"form\"&gt; &lt;el-table ref=\"table\" :data=\"form.tableData\" empty-text='暂无数据'&gt; &lt;el-table-column label=\"姓名\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form-item &gt; &lt;el-input v-model=\"scope.row.name\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"年龄\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form-item &gt; &lt;el-input v-model.number=\"scope.row.age\" type=\"number\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-button type=\"danger\" size=\"mini\" @click=\"del(scope.$index)\" icon='el-icon-delete'&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" size=\"mini\" @click=\"add\" icon='el-icon-plus'&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; form: &#123; tableData: [ &#123; name: \"aaa\", age: 11 &#125;, &#123; name: \"\", age: '' &#125; ] &#125; &#125;; &#125;, methods:&#123; add()&#123; this.form.tableData.push(&#123; name: \"\", age: '' &#125;) &#125;, del(index)&#123; this.form.tableData.splice(index,1); &#125; &#125;&#125;;&lt;/script&gt; el-table 数据是数组 , el-form 数据是对象 添加校验 Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。 方法一 123&lt;el-form :rules='rules' ...&gt;&lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.name' \" :rules='rules.name'&gt; 123456789data()&#123; return &#123; rules: &#123; name: [ &#123; required: true, message: '名字不能为空', trigger: 'blur' &#125; ] &#125; &#125;&#125; 方法二 1&lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.name' \" :rules=\"&#123; required: true, message: '名字不能为空', trigger: 'blur' &#125;\"&gt; 12345678&lt;el-table-column label=\"姓名\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.name' \" :rules=\"&#123; required: true, message: '名字不能为空', trigger: 'blur' &#125;\"&gt; &lt;el-input v-model=\"scope.row.name\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/template&gt; &lt;/el-table-column&gt; 自己写校验方法方法1 : 对应上面的方法1,校验犯法写在data中. 12345678910111213141516171819202122232425262728293031323334353637383940414243data() &#123; var checkAge = (rule, value, callback) =&gt; &#123; if (!value) &#123; return callback(new Error('年龄不能为空')); &#125;else if(!Number.isInteger(value) )&#123; callback(new Error('请输入数字值')); &#125;else if(value &lt; 18)&#123; callback(new Error('必须年满18岁')); &#125;else if(value &gt;50)&#123; callback(new Error('小于50岁')); &#125;else&#123; callback(); &#125; &#125;; var checkName = (rule, value, callback) =&gt; &#123; let regName =/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/; if (!value) &#123; return callback(new Error('姓名不能为空')); &#125;else if(!regName.test(value))&#123; callback(new Error('请输入正确的姓名')); &#125;else&#123; callback(); &#125; &#125;; return &#123; form: &#123; tableData: [ &#123; name: \"\", age: '' &#125; ] &#125;, rules: &#123; name: [ &#123; required: true, trigger: 'blur' ,validator: checkName&#125; ], age: [ &#123; required: true, trigger: 'blur', validator: checkAge&#125; ], &#125; &#125;; &#125;, 方法2: 对应上面的方法2,校验犯法写在methods中. 123&lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.name' \" :rules=\" &#123; required: true, trigger: 'blur' ,validator: checkName&#125;\"&gt;&lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.age' \" :rules=\" &#123; required: true, trigger: 'blur' ,validator: checkAge&#125;\"&gt; 12345678910111213141516171819202122232425methods:&#123; checkAge (rule, value, callback) &#123; if (!value) &#123; return callback(new Error('年龄不能为空')); &#125;else if(!Number.isInteger(value) )&#123; callback(new Error('请输入数字值')); &#125;else if(value &lt; 18)&#123; callback(new Error('必须年满18岁')); &#125;else if(value &gt;50)&#123; callback(new Error('小于50岁')); &#125;else&#123; callback(); &#125; &#125;, checkName (rule, value, callback) &#123; let regName =/^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/; if (!value) &#123; return callback(new Error('姓名不能为空')); &#125;else if(!regName.test(value))&#123; callback(new Error('请输入正确的姓名')); &#125;else&#123; callback(); &#125; &#125; &#125; 同table中，某字段不能重复 同table中,不能写相同的电话号码的校验 1234567891011121314&lt;el-table-column label=\"电话号码\"&gt; &lt;template slot-scope=\"scope\"&gt; &lt;el-form-item :prop=\" 'tableData.' + scope.$index + '.tel' \" :rules=\" &#123; required: true, trigger: 'blur' ,validator: checkTel&#125;\" &gt; &lt;el-input v-model.number=\"scope.row.tel\" type=\"number\" @blur=\"telequalCheckblur(scope.$index,scope.row.tel)\" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/template&gt; &lt;/el-table-column&gt; 12345678910111213141516171819202122methods:&#123; checkTel(rule, value, callback) &#123; let regTel = /^(((1[3456789][0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/; let index = rule.field.split(\".\")[1]; if (!value) &#123; return callback(new Error(\"电话号码不能为空\")); &#125; else if (!regTel.test(value)) &#123; callback(new Error(\"请输入正确的电话号码\")); &#125; else if (this.telequalCheck(index, value)) &#123; callback(new Error(\"电话号码重复,请重新填写\")); &#125; else &#123; callback(); &#125; &#125;, //相等判断 telequalCheck(index, value) &#123; return this.form.tableData.some((&#123; tel &#125;, i) =&gt; &#123; console.log(i, index, i == index); return i == index ? false : tel === value; &#125;); &#125;,&#125; 必填*显示1. 输入框前加* 正常来说,在el-form中,使用rules的required: true,就能显示*了. 因为是在表格中,所以表单就不使用label了,所以这时必填选项的*没有了. 注意:这里面label=' '必须有空格,否则还是没有* 2. 表头加* 1.el-table&gt;添加 header-cell-class-name=’required’ 2. elment 有默认的样式,如果不想要,就换个class名字 header-cell-class-name='requiredclass' 1234567&lt;style&gt;.requiredclass&gt;div.cell::before&#123; content: \"*\"; color: #f56c6c; margin-right: 4px;&#125;&lt;/style&gt; 3. 只加某几个 :header-cell-class-name='addHeaderCellClassName' 123456addHeaderCellClassName(&#123;row, column, rowIndex, columnIndex&#125;)&#123; if(columnIndex===0 || columnIndex===1)&#123; return 'requiredclass' &#125; &#125;//这里放在data或者methods中都可以 4. 自定义表头 在需要添加*的位置添加自定义表头 12345.requiredclass::before&#123; content: \"*\"; color: #f56c6c; margin-right: 4px;&#125; 删除某行,同时删除这行的校验结果问题: 删除某行时,这行的校验结果不随着删除 观察图片,删除第三行,第三行的校验结果,还在. 解决方法 删除时,对表单进行校验 1234del(index) &#123; this.form.tableData.splice(index, 1); this.$refs.form.validate()&#125;,","tags":[{"name":"elementUI","slug":"elementUI","permalink":"http://zhaokunming.xyz/tags/elementUI/"}]},{"title":"el-form实现回车进入下一个输入框","date":"2019-06-17T11:08:12.000Z","path":"2019/06/17/el-form实现回车进入下一个输入框/","text":"在开发vue项目中，element-ui用的算是最多的，开发后台管理系统：表格、表单……可以说是很多了，回车跳转到下一个输入框可以节省大量的时间，也可以减少冗余性，减少不耐烦……题外话 在饿了么ui框架中的form表单中需要加入回车跳转到下一个输入框的功能，大致。。。我是说目前知道的有两种，一种是我认为比较轻便简单的方法：自定义局部指令或者全局指令。另一种键盘事件，定义一个methods。 代码如下： 自定义指令 123456789101112131415161718192021222324252627directives: &#123; // 注册一个局部的自定义指令 v-focus //回车转换输入框 enterToNext: &#123; // 指令的定义 inserted: function(el) &#123; console.log(\"enterToNext...\"); //let frm = el.querySelector('.el-form'); let inputs = el.querySelectorAll(\"input\"); //绑定回写事件 // console.log(inputs); for (var i = 0; i &lt; inputs.length; i++) &#123; inputs[i].setAttribute(\"keyFocusIndex\", i); inputs[i].addEventListener(\"keyup\", ev =&gt; &#123; if (ev.keyCode === 13) &#123; let targetTo = ev.srcElement.getAttribute(\"keyFocusTo\"); if (targetTo) &#123; this.$refs[targetTo].$el.focus(); &#125; else &#123; var attrIndex = ev.srcElement.getAttribute(\"keyFocusIndex\"); var ctlI = parseInt(attrIndex); if (ctlI &lt; inputs.length - 1) inputs[ctlI + 1].focus(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125;, 注册完成之后，直接在el-form中使用即可，不必给每个input框都添加一个自定义指令 methods方法 1234567891011121314151617181920212223242526272829303132333435export default &#123; data() &#123; return &#123; inputDoms: \"\", &#125;; &#125;, created() &#123; this.$nextTick(() =&gt; &#123; this.initInputDOM(); &#125;); &#125;, methods: &#123; initInputDOM() &#123; const inputDoms = document.querySelectorAll( \"#table-form .el-input__inner\" ); inputDoms.forEach((item, index) =&gt; &#123; item.setAttribute(\"data-index\", index); &#125;); this.inputDoms = inputDoms; &#125;, nextFocus(event, row) &#123; const index = event.target.getAttribute(\"data-index\"); const nextIndex = parseInt(index) + 1; const length = this.inputDoms.length; if (nextIndex &lt; length) &#123; this.inputDoms[nextIndex].focus(); &#125; else &#123; this.inputDoms[0].focus(); &#125; &#125;, &#125;&#125;;&lt;/script&gt; 之后在需要回车跳转的input框中添加键盘事件 1&lt;el-input @keyup.native.enter=\"nextFocus($event,scope.row)\"&gt;&lt;/el-input&gt; 这种需要为每一个需要回车的input框添加键盘事件，但是当一个form中有很多输入框时，就显得繁琐了","tags":[{"name":"elementUI","slug":"elementUI","permalink":"http://zhaokunming.xyz/tags/elementUI/"}]},{"title":"elementUI中DateTimePicker日期时间选择器的范围限制","date":"2019-04-02T11:17:18.000Z","path":"2019/04/02/element-ui可选时间限制/","text":"项目写了一个后台管理系统，用到了饿了么UI，日期选择器这一块我感觉是用到的挺多的，开始时间，结束时间，巴拉巴拉一大堆。简单的层面，组件的使用是没有问题的。那么需求就来了，开始时间选中之后，结束时间不可选择开始时间之前的时间。很绕口吧。 先看一下实现之后的效果图： 1234大致效果就是:&#123; 1、开始时间先选择，结束时间不可选择开始时间之前的时间； 2、结束时间先选择，开始时间不可选择结束时间之后的时间；&#125; 因为项目是使用vue框架写的，所以分为两个部分填充代码： element的DateTimePicker日期时间选择器组件中： 1234567891011121314151617181920212223&lt;el-form-item label=\"创建日期：\" prop=\"createTimeBegin\"&gt; &lt;el-date-picker v-model=\"formData.createTimeBegin\" style=\"width:60%\" type=\"date\" placeholder=\"开始日期\" value-format=\"yyyy-MM-dd\" :picker-options=\"pickerOptionscreateTimeBegin\"----&gt;此处为添加 &gt;&lt;/el-date-picker&gt;&lt;/el-form-item&gt;&lt;!-------------------------------&gt;&lt;el-form-item label=\"至\" style=\"text-align:left\" prop=\"createTimeEnd\"&gt; &lt;el-date-picker v-model=\"formData.createTimeEnd\" style=\"width:60%\" type=\"date\" placeholder=\"结束日期\" value-format=\"yyyy-MM-dd\" :picker-options=\"pickerOptionscreateTimeEnd\" &gt;&lt;/el-date-picker&gt;&lt;/el-form-item&gt; data中： 1234567891011121314151617181920data()&#123; return&#123; pickerOptionscreateTimeBegin: &#123; disabledDate: time =&gt; &#123; const endDateVal = new Date(this.formData.createTimeEnd).getTime(); if (endDateVal) &#123; return time.getTime() &gt;= endDateVal; &#125; &#125; &#125;, pickerOptionscreateTimeEnd: &#123; disabledDate: time =&gt; &#123; const beginDateVal = new Date(this.formData.createTimeBegin).getTime(); if (beginDateVal) &#123; return time.getTime() &lt;= beginDateVal; &#125; &#125; &#125;, &#125;&#125; 应该开始时间和结束时间两者都设置，且顺序不能错，当然，你也可以写错试试效果，注意data中的代码，不要想当然; 这里会有点小bug，因为会有误差，所以，时间范围可能会出现开始时间和结束时间不能相同的bug，能做的只能是尽量减少误差，比如 123return time.getTime() &gt; endDateVal-86400000;return time.getTime() &lt; beginDateVal-86400000; 可以适当减去相应毫秒数","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"},{"name":"elementUI","slug":"elementUI","permalink":"http://zhaokunming.xyz/tags/elementUI/"}]},{"title":"下拉复选框","date":"2019-03-05T08:44:32.000Z","path":"2019/03/05/下拉复选框/","text":"转自：https://cloud.tencent.com/developer/article/1357756 因为项目需要，在网上找了一下，觉得这篇文章写的还是很不错的，怕以后链接失效，所以摘录下来转载到自己的博客中。 （改善：当遇到选项比较多时，可以定义一个数组插入到HTML中，实现下拉的选项，可以参考省市区联动的写法） 代码如下：（注意：需引进jquery） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;style&gt; div &#123; display: inline-block; &#125; select &#123; min-width: 200px; height: 25px; border: 1px solid #000; &#125; ul &#123; display: none; list-style: none; margin: 0; padding: 0; border: 1px solid #000; &#125; label &#123; display: block; padding: 2px 10px; white-space: nowrap; &#125; ul li:hover &#123; background-color: #aabbcc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;select name=\"\" id=\"lang1\"&gt;&lt;/select&gt; &lt;ul id=\"ck1\"&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;HTML&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;CSS&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;JavaScript&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;jQuery&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;PHP&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;MySQL&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;hr&gt; &lt;!--HTML结构不能变--&gt; &lt;div&gt; &lt;select name=\"\" id=\"lang2\"&gt;&lt;/select&gt; &lt;ul id=\"ck2\"&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;Java&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;C#&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;C++&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;Pyhton&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type=\"button\" onclick=\"console.log(&#123;'tag1':tag1,'tag2':tag2,&#125;)\" value=\"查看字段\"&gt; &lt;script&gt; /** * [dropDownCk 下拉复选框] * @param &#123;[String]&#125; boxId [父级元素id] * @param &#123;[String]&#125; selectId [下拉选id] * @param &#123;[String]&#125; hiddenId [隐藏区域id] * @return &#123;[Array]&#125; [description] */ function dropDownCk(selectId,hiddenId) &#123; var boxId = \"#\" + boxId, selectId = \"#\" + selectId, hiddenId = \"#\" + hiddenId; $(hiddenId).mouseleave(function()&#123; // 鼠标离开隐藏复选区域 $(this).hide(); &#125;); $(selectId).click(function() &#123; // 切换显示与隐藏 $(hiddenId).toggle(); &#125;); var tagArr = []; // 接收复选字段数组 $(selectId).html(\"&lt;option checked='true' style='display:none;'&gt;\" + \"请选择项目\" + \"&lt;/option&gt;\"); $(hiddenId + ' label').find('input').click(function() &#123; // 点击向数组添加元素 if ($(this).is(':checked')) &#123; tagArr.push($(this).parent().text()); $(selectId).html(\"&lt;option checked='true' style='display:none;'&gt;\" + tagArr.join(\",\") + \"&lt;/option&gt;\"); &#125; else &#123; tagArr.splice(tagArr.indexOf($(this).parent().text()), 1); // 删除对应元素 if (tagArr.length == 0) &#123; $(selectId).html(\"&lt;option checked='true' style='display:none;'&gt;\" + \"请选择项目\" + \"&lt;/option&gt;\"); &#125; else &#123; $(selectId).html(\"&lt;option checked='true' style='display:none;'&gt;\" + tagArr.join(\",\") + \"&lt;/option&gt;\"); &#125; &#125; &#125;); return tagArr; &#125; var tag1 = dropDownCk(\"lang1\",\"ck1\"); var tag2 = dropDownCk(\"lang2\",\"ck2\"); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"http://zhaokunming.xyz/tags/jquery/"}]},{"title":"多个复选框中的联动","date":"2019-02-13T06:09:26.000Z","path":"2019/02/13/多个复选框中的联动/","text":"复选框之间的联动，主要就是全选、反选和子复选框之间的联动问题，用到的地方还是挺多的，购物车，后台列表等很多地方。虽然是最基础的一个逻辑问题，对于初学者来说，理解起来可能不是很容易。 主要的思路如下： 按照上面的思路走，我们会发现实现全选联动，并不复杂，图中有多个判断条件，那么用到的最多的可能就是if语句了 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #every&#123; border: 1px solid orange; width: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; window.onload=function()&#123; var aBtn=document.getElementById('all'); var everyBox=document.getElementById('every'); var cbs=everyBox.getElementsByTagName('input'); console.log(cbs) aBtn.onclick=function()&#123; if(aBtn.checked == true)&#123; for(let i=0;i&lt;cbs.length;i++)&#123; cbs[i].checked=true &#125; &#125;else&#123; for(let i=0;i&lt;cbs.length;i++)&#123; cbs[i].checked=false &#125; &#125; &#125; for(let i=0;i&lt;cbs.length;i++)&#123; cbs[i].onclick=function()&#123; let n=0; for(let i=0;i&lt;cbs.length;i++)&#123; if(cbs[i].checked===true)&#123; n++; &#125; &#125; if(n===cbs.length)&#123; aBtn.checked=true &#125;else&#123; aBtn.checked=false &#125; &#125; &#125; &#125; &lt;/script&gt; 全选：&lt;input type=\"checkbox\" id=\"all\"&gt; &lt;div id=\"every\"&gt; 复选框一：&lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;&lt;br/&gt; 复选框二：&lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;&lt;br/&gt; 复选框三：&lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;&lt;br/&gt; 复选框四：&lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;&lt;br/&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"}]},{"title":"vue实现页面的局部刷新","date":"2019-01-16T08:48:16.000Z","path":"2019/01/16/vue实现页面的局部刷新/","text":"vue中如何实现页面的局部刷新？vue主要是组件组成的，那么这也就为我们提供了最好的局部刷新的方法，因为是各个组件拼接成一个页面，那么当我们部分需要更新数据时，就不需要更新整个页面，只需要刷新一小部分，这样间接的也进行了性能优化，大大的提高的加载速度。 Vue中对数据进行增删改查的操作之后, 希望页面显示的是我们操作之后最新的数据, 为了避免重新做axios请求, 此时用到组件的刷新是很方便的了, 以下便是我做项目中总结的组件局部刷新的方法: 1、利用Vue里面的provide+inject组合 这种方法主要是用到的v-if的特性，对dom元素的销毁与重新渲染，emmm，这不正是刷新所需要的吗？ 1、首先需要修改App.vue,在App.vue中使用provide App.vue的template模板中 App.vue的script中 123456789101112131415161718192021222324252627282930//App.vue&lt;template&gt; &lt;div&gt; &lt;router-view v-if=\"isRouterAlive\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'App', data()&#123; return &#123; isRouterAlive: true &#125; &#125;, provide()&#123; //提供 return &#123; reload: this.reload &#125; &#125;, methods: &#123; reload()&#123; this.isRouterAlive = false this.$nextTick(function()&#123; this.isRouterAlive = true &#125;) &#125; &#125; &#125;&lt;/script&gt; 2、到需要刷新的页面进行引用，使用inject导入引用reload，然后直接调用即可 这里我是在按钮上定义了一个方法 在需要更新的页面中引入reload 直接调用 123456789101112131415&lt;script&gt; export default &#123; name: 'myComponent', data() &#123; return &#123;&#125; &#125;, inject: ['reload'], //注入 methods: &#123; myCallBack()&#123; // ... this.reload() //局部刷新 &#125; &#125; &#125;&lt;/script&gt; 这种方法我认为还是很好的，不需要发起多余的请求，也不会出现空白页，复用性也很强，很推荐使用 以下还有几种我在网上拓展的刷新方法，因为大多会出现空白页，不美观，体验差，不是很推荐 2、利用window.location.reload() //有白屏 默认参数是 false，它会用 HTTP 头 If-Modified-Since 来检测服务器上的文档是否已改变；如果文档已改变，reload() 会再次下载该文档；如果文档未改变，则该方法将从缓存中装载文档。这与用户单击浏览器的刷新按钮的效果是完全一样的。 参数为 true，无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样 3、利用this.$router.go(0) //有白屏 4、先跳转到一个空白页面再跳转回来 //虽不会一闪，但是能看见路由快速变化 12//需要页面刷新的地方，跳转到一个空白页this.$router.push('/emptyPage') 123456//空白页beforeRouteEnter (to, from, next) &#123; next(vm =&gt; &#123; vm.$router.replace(from.path) &#125;)&#125;","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"},{"name":"局部刷新","slug":"局部刷新","permalink":"http://zhaokunming.xyz/tags/%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0/"}]},{"title":"css，js以及web性能优化","date":"2019-01-03T10:45:29.000Z","path":"2019/01/03/css，js以及web性能优化/","text":"Css优化总结 对于css的优化可以从网络性能和css语法优化两方面来考虑。 Css性能优化方法如下： 1、css压缩Css 压缩虽然不是高端的知识，但是很有用。其原理也很简单，就是把我们css代码中没有用的空白符等删除，达到缩减字符个数的目的。 压缩css代码的工具： A、YUI compressor，可以在线压缩css和js代码。 B、gulp自动化构建工具，中的gulp-minify-css。 2、gzip压缩Gzip是一种流行的文件压缩算法，现在应用的十分广泛，尤其实在Linux这个平台上，这个不止是对css，当应用Gzip压缩一个文本时，效果是非常明显的。大约可以减少70%以上的文件大小（这取决于文件中的内容）。 在没有 gzip压缩的情况下，web服务器直接把html页面、css脚本以及js脚本发送到浏览器，而支持gzip的浏览器在本地进行解压和解码，并显示原文件。这样我们传输的文件字节数减少了，自然可以达到网络性能优化的目的。Gzip压缩需要服务器的支持，所以需要在服务器端进行配置。 3、合写css（通过少些css属性来达到减少css字节吗的目的）例子： background:#000 url(image.jpg) top left no-repeat; font:font-style font-weight font-size font-familiy; margin:5px 10px 20px 15px; padding:5px; border:2px 5px 10px 3px; border-top:2px 5px 10px 3px; 4、利用继承Css的继承机制可以帮我们在一定程度上缩减字节数，我们知道css很多属性可以继承，即在父容器设置了默认属性，子容器会默认也使用这些属性。 可继承的属性举例： 所有元素都可以继承的属性：visibility 、cursor 内联元素和块元素可以继承的属性：Letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 块状元素可以继承的属性：Text-indent、text-align； 列表元素可以继承的属性：List-style、list-style-type、list-style-position、list-style-image 表格元素可以继承的属性：Border-collapse 不可以继承的属性：Display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-break-before、unicode-bidi 5、抽离、拆分css，不加载所有css抽离原则：在很多时候，我们把页面通用的css写到了一个文件，这样加载一次后，就可以利用缓存，但这样做兵不适合所有的场景。所以抽离拆分的时候要考虑好。 6、css放在head中，减少repaint和reflowCss方法在页面的顶部，有利于优化的原因？？？ 当浏览器从上到下一遍下载html生成dom tree，一边根据浏览器默认以及现有css生成render tree来渲染页面。当遇到新的css的时候下载并结合现有css重新生成render tree。则刚才的渲染功能就全废了。当我们把所有css放在页面的顶部，就没有重新渲染的过程了。 脚本中应该尽量少用repaint和reflow： Reflow：当dom元素出现隐藏/显示，尺寸变化。位置变化的时候，逗号让浏览器重新渲染页面，以前的渲染工作白费了。 Repaint：当元素的背景颜色，边框颜色变化的时候，不会引起reflow的变化，是会让浏览器重新渲染该元素。 7、避免使用通配符或隐式通配符：visible.8、避免层级或过度限制css（css是从右向左解析的）A、不要用标签或class来限制id。#test .info /div #test这都属于画蛇添足Id已经可以唯一而且快速的定位到一个元素了。 B、不要用标签限制classDiv .info 不好在css代码编写中，如果直接使用class不能达到目的，一般是class设计出现了问题，css需要重构。 C、尽量使用最具体的类别，避免使用后代选择器，在css选择器中，后代选择器非但没有加快css查找，反而后代选择器是css中耗费最贵的。 JavaScript优化总结 1、避免全局查找在一个函数中尽量将全局对象存储为局部变量来查找，因为访问局部变量的数要更快一些。 12345function()&#123;alert(window.location.href+window.location.host);&#125; 修改为： 1234567funciton()&#123;var location=window.location;alert(location.href+location.host);&#125; 2、定时器如果针对的是不断运行的代码，不应该使用setTimeout，而应该使用setInterval。因为setTimeout每一次都会初始化一个定时器。而setInterval只会在开始的时候初始化一个定时器。 12345678910111213var timeoutTimes=0;function timeout()&#123; timeoutTimes++; if(timeoutTimes&lt;10)&#123; setTimeout(timeout,10); &#125;&#125; 修改为： 123456789101112131415var intervalTimes=0;function interval()&#123; intervalTimes++; if(intervalTimes&gt;=10)&#123; clearInterval(interval)'' &#125;&#125;var interval = setInterval(interval,10); 3、字符串连接如果需要连接多个字符串，应该少使用+=： 如 1s+=a;s+=b;s+=c; 修改为： 1s+=a+b+c; 而如果是收集字符串，比如多次对同一个字符进行+=操作的话，最好使用一个缓存，使用js数组来收集，最后join方法连接起来。 123456789var buf=[];for(var i=0;i&lt;100;i++)&#123; buf.push(i.toString());&#125;var all=buf.join(\"\"); 4、避免with语句和函数类似，with语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。犹豫额外的作用域链的查找，在with语句中执行的代码肯定会比外面执行的低吗要慢，在能不使用with语句的时候，尽量不要使用with语句。 1234567with(a,b,c,d)&#123; property1=1; property2=2;&#125; 修改为： 12345var obj=a.b.c.d;obj.property1=1;obj.property2=2; 5、数字转为字符串一般用“”+1来将数字转为字符串，虽然看起来比较丑一点，但事实上这个效率最高。 （“”+1）&gt;String()&gt;.toString()&gt;new String() 6、浮点数转化为整型很多人喜欢使用pareseInt(),其实parseInt()是用于将字符串转为数字，而不是浮点数和整型之间的转换。我们应该使用的是Math.floor()或Math.round(); 7、多个类型声明所有变量可以使用单个var语句来声明，这样就是组合在一起的语句，以减少整个脚本的执行时间。 12345var A=1, B=2, C=3; 8、使用直接量12345var aTest=new Array();//var aTest=[]var aTest=new Object();//var aTest=&#123;&#125;var reg=new RegExp();//var reg=/ /; 创建具有特殊性的一般对象，也可以使用字面量。 12345var oFruit=new O();oFruit.color=\"red\";oFruit.name=\"apple\"; 应改为 1var oFruit=&#123;color:\"red\",name:'apple'&#125; 9、使用DocumentFragment优化多次的append一旦需要跟新DOM，请考虑使用文档碎片来构建结构，然后再添加到现有的文档中。 123456789for(var i=0;i&lt;1000;i++)&#123; varel=document.createElement('p'); el.innerHTML=i; document.body.append(el);&#125; 应该改为 12345678910111213var frag=document.createDocumentFragment();for(var i=0;i&lt;1000,i++)&#123; varel=document.createElement('p'); el.innerHTML=i; frag.append(el);&#125;document.body.appendChild(frag); 10、使用一次innerHTML复制代替构建dom元素。对于大的dom更改，使用innerHTML要比使用标准的dom方法创建同样的dom结构快的多。 12345678910111213varfrag=document.createDocumentFragment();for(var i=0;i&lt;1000;i++)&#123; varel=document.createElement('p'); el.innerHTML=i; frag.appendChild(el);&#125;document.body.appendChild(frag); 应该改为 123456789var html=[];for(var i=0;i&lt;1000;i++)&#123; html.push('&lt;p&gt;'+i+\"&lt;/p&gt;\");&#125;document.body.innerHTML=html.join(\"\"); 11、使用firstChild和nextSibling代替childNodes遍历dom元素。1234567var nodes=element.childNodes;for(var i=0,l=nodes.length;i&lt;l;i++)&#123; varnode=nodes[i];&#125; 应该改为 1234567var node=element.firstChild;while(node)&#123; node.node.nextSibling;&#125; 12、删除dom节点删除dom节点之前，一定要删除注册在该节点上的事件，不管是observe方式还是用attachEvent方式注册的事件。否则将会产生无法回收的内存。另外，removeChild和innerHTML=‘’两者之间尽量选择后者，因为在内存泄漏工具中监测的结果是用removeChild无法有效的释放dom节点。 13、简化终止条件由于每次循环过程，都会计算终止条件。所以必须保证他尽可能的快。也就是避免属性查找或其他操作。最好是将循环控制量保存到局部变量中，也就是说对数组或列表对象遍历的时候，提前将length保存到局部变量中，避免循环的每一步重复取值。 123456varlist=document.getElementsByTagName('p');for(var i=0;i&lt;list.length;i++)&#123;&#125; 应该改为 123for(var i=0,l=list.length;i&lt;l;i++)&#123;&#125; 14、使用后测试循环在js中，我们使用for(;;),while(),for(in)三种循环。for(in)的效率极差。因为他需要查询散列键，只要可以，就应该尽量少用。 for(;;)和while循环，while优于for（；；）,可能for（；；）结构问题，需要经常的跳转。do..while更好。 15、尽量少用eval函数使用eval函数相当于在运行时，再次调用解释引擎对内容进行运行，需要消耗大量时间，而且使用eval带来的安全性问题也是不容忽视的。 16、不要给setTimeout或setInterval传递字符串参数。123var num=0;setTimeout(num++,10); 应该改为 123456789var num=0;function addNum()&#123; num++;&#125;setTimeout(addNum,10); 17、缩短否定检测12345if(oTest!=\"#ff0000\")&#123;&#125;if(oTest!=null)&#123;&#125;if(oTest!=false)&#123;&#125; 以上都不太好 1if(!oTest)&#123;这个比较好&#125; 18、可以用三目运算符替换条件分支，可以提高效率。 Web性能优化 1、避免坏请求有时候页面中的html或css会向服务器请求一个不存在的资源，比如图片或者html文件，这会造成浏览器与服务器之间过多的往返请求。 类似于： 浏览器：“我需要这个图像”服务器：“我没有这个图像”浏览器：“你确定吗？这个文档说你有”服务器：“真的没有” 这个降低页面加载速度。因此检查坏连接很有必要。可通过Google的PageSpeed工具，找到问题后，补充相当资源文件或者修改资源链接地址即可。 2、避免css@import使用@import方法引用css文件可能会带来一些影响页面加载速度的问题。比如导致文件按顺序加载（一个加载完成后才会加载另一个），无法并行加载； 检查工具：css delivery 查到@import url(“style.css”)就替换为：&lt;link….&gt; 3、避免使用document.write在js中，可以使用document.write。在网页上显示内容或者调用外部资源，而通过此方法，浏览器采取一些多余的步骤（下载资源，读取资源）。运行js来了解需要做什么，调用其他资源时，需要重新在执行一次这个过程。由于浏览器之前不知道要显示什么，所以会降低页面加载的速度。 要知道，任何能够被document.write调用的资源，都可以通过html调用。这样速度会更快 1document.write('&lt;script src=\"another.js\"&gt;&lt;/script&gt;'); 改为 1&lt;script src=\"another.js\"&gt;&lt;/script&gt; 4、合并多个外部css文件网站中每使用一个css文件，都会让你的页面加载速度慢一点。可以css delivery工具，来检测页面代码中css文件。然后通过复制粘贴合并成一个。 5、合并多个外部js文件可以用resource check来检测页面中所引用的js文件数，然后可以通过复制粘贴的方法将多个文件合并成一个。 6、通过css sprites来整合图像若页面中有6个小图像，那么浏览器在显示时会分别下载，你可以通过css sprites将这些图像合并成为一个，可以减少页面加载所需要的时间。 Css sprites两个步骤：整合图像，定位图像 7、延迟js加载浏览器在执行js代码时，会停止处理页面。当页面中很多js文件或者代码要加载时，将导致严重的延迟。尽管可以使用defer，异步或将js代码放自爱页面底部来延迟js的加载。但这些都不是一个好的解决方案。 好方法 123456789101112131415161718192021222324252627&lt;script&gt;function downloadJSAtOnload()&#123; varelement=document.createElement(\"script\"); element.src=\"defer.js\"; document.body.appendChild(element);&#125;if(window.addEventListener)&#123; window.addEventListener('load',downloadJSAtOnload,false);&#125;else if(window.attachEvent)&#123; window.attachEvent('onload',downloadJSAtOnload);&#125;else&#123; window.οnlοad=downloadJSAtOnload;&#125;&lt;/script&gt; 8、启用压缩/Gzip使用gzip对html和css文件进行压缩，通常可以大约节省50%到70%，这样加载页面只需要更少的带宽和更少的时间。 9、如果你的css和js较小，可以将css和js内嵌到html页面中，这样可以减少页面加载所需要的文件数，从而加快页面的加载。10、用minify css压缩css代码11、尽量减少dns查询次数当浏览器和服务器建立链接时，它需要进行dns解析，将域名解析为ip地址，然而，一旦客户端需要执行dns lookup时，等待时间将会取决于域名服务器的有效响应速度。 虽然所有的isp的dns服务器都能缓存域名和ip地址映射表。但如果缓存的dns记录过期了而需要更新，则可能需要遍历多个dns节点，有时候需要通过全球范围内来找到可信任的域名服务器，一旦域名服务器工作繁忙，请求解析时，就需要排队则进一步延时等待时间。 所有减少dns查询次数很重要，页面加载就尽量避免额外耗时，为了减少dns查询次数，最好的解决方法就是在页面中减少不同的域名请求的机会、 可通过request checker工具来检测页面中存在多少请求后，进行优化。 12、尽量减少重定向有时候为了特定需求，需要在网页中使用重定向。重定向的意思是，用户的原始请求（如请求A）被重定向到其他的请求（如请求B）； 网页中使用重定向会造成网站性能和速度下降，因为浏览器访问网址是一连串的过程，如果访问到一半，而跳转到新的地址，就会重复发起一连串的过程，这将浪费很多时间。所有我们尽量避免重定向。Google建议 A、不要链接到一个包含重定向的页面 B、不要请求包含重定向的资源 13、优化样式表和脚步顺序Style标签和样式表调用代码应该放置在js代码的前面，这样可以使页面的加载速度加快。 14、避免js阻塞渲染浏览器在遇到一个引入外部js文件的&lt; script /&gt;标签时，会停下所有工作下载并解析执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。这是页面加载就会停止。 谷歌建议删除干扰页面第一屏内容加载的js，第一屏指的是用户在屏幕中最初看到的页面，无论桌面浏览器，还是手机 15、指定图像尺寸当浏览器加载页面的html时，有时候需要在图片下载完成前，对页面布局进行定位。如果hmtl里的图片没有指定尺寸，或者代码描述的尺寸和实际的图片尺寸不符合时，浏览器需要在图片下载完成后在回溯到该图片，并重新显示，这将消耗额外的时间。 最好的页面中每一张图片都指定尺寸，不管在html里的img中，还是在css中。","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"css","slug":"css","permalink":"http://zhaokunming.xyz/tags/css/"},{"name":"web性能优化","slug":"web性能优化","permalink":"http://zhaokunming.xyz/tags/web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"axios拦截器","date":"2018-12-16T09:31:44.000Z","path":"2018/12/16/axios拦截器/","text":"页面发送http请求，很多情况我们要对请求和其响应进行特定的处理；如果请求数非常多，单独对每一个请求进行处理会变得非常麻烦，程序的优雅性也会大打折扣。好在强大的axios为开发者提供了这样一个API：拦截器。拦截器分为 请求（request）拦截器和 响应（response）拦截器。 axios拦截器简单介绍 请求拦截器 1234567axios.interceptors.request.use(function (config) &#123; // 在发起请求请做一些业务处理 return config; &#125;, function (error) &#123; // 对请求失败做处理 return Promise.reject(error); &#125;); 响应拦截器 1234567axios.interceptors.response.use(function (response) &#123; // 对响应数据做处理 return response; &#125;, function (error) &#123; // 对响应错误做处理 return Promise.reject(error); &#125;); vue添加axios拦截器 安装 axios npm install axios –save-dev 新建文件 axios.js 开始统一封装axios， 首先引入axios、qs依赖 12import axios from \"axios\";import qs from \"qs\"; 然后创建一个axios实例，这个process.env.BASE_URL在config/dev.evn.js、prod.evn.js里面进行配置： 12345/****** 创建axios实例 ******/const service = axios.create(&#123; baseURL: process.env.BASE_URL, // api的base_url timeout: 5000 // 请求超时时间&#125;); 使用request拦截器对axios请求配置做统一处理 1234567891011121314151617service.interceptors.request.use(config =&gt; &#123; app.$vux.loading.show(&#123; text: '数据加载中……' &#125;); config.method === 'post' ? config.data = qs.stringify(&#123;...config.data&#125;) : config.params = &#123;...config.params&#125;; config.headers['Content-Type'] = 'application/x-www-form-urlencoded'; return config; &#125;, error =&gt; &#123; //请求错误处理 app.$vux.toast.show(&#123; type: 'warn', text: error &#125;); Promise.reject(error) &#125;); 对response做统一处理 123456789101112131415161718192021222324252627service.interceptors.response.use( response =&gt; &#123; //成功请求到数据 app.$vux.loading.hide(); //这里根据后端提供的数据进行对应的处理 if (response.data.result === 'TRUE') &#123; return response.data; &#125; else &#123; app.$vux.toast.show(&#123; //常规错误处理 type: 'warn', text: response.data.data.msg &#125;); &#125; &#125;, error =&gt; &#123; //响应错误处理console.log('error'); console.log(error); console.log(JSON.stringify(error)); let text = JSON.parse(JSON.stringify(error)).response.status === 404 ? '404' : '网络异常，请重试'; app.$vux.toast.show(&#123; type: 'warn', text: text &#125;); return Promise.reject(error) &#125;) 将axios实例暴露出去 1export default service; 这样一个简单的拦截器就完成了 在main.js中进行引用，并配置一个别名（$ajax）来进行调用 1234import axios from 'axios'import '../axios.js' //axios.js的路径Vue.prototype.$ajax = axios 应用：一个简单的登录接口 12345678910this.$ajax(&#123; method: 'post', url: '/login', data: &#123; 'userName': 'haha', 'password': '123456' &#125;&#125;).then(res =&gt; &#123; console.log(res)&#125;) 使用场景 eg: axios拦截器对路由进行拦截 1.路由拦截 在定义路由的时候就需要多添加一个自定义字段requireAuth，用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由，否则就进入登录页面。 1234567891011121314151617181920const routes = [ &#123; path: '/', name: '/', component: Index &#125;, &#123; path: '/repository', name: 'repository', meta: &#123; requireAuth: true, // 添加该字段，表示进入这个路由是需要登录的 &#125;, component: Repository &#125;, &#123; path: '/login', name: 'login', component: Login &#125;]; 定义完路由后，我们主要是利用vue-router提供的钩子函数beforeEach()对路由进行判断。 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.meta.requireAuth) &#123; // 判断该路由是否需要登录权限 if (token) &#123; // 判断当前的token是否存在 next(); &#125; else &#123; next(&#123; path: '/login', query: &#123;redirect: to.fullPath&#125; // 将跳转的路由path作为参数，登录成功后跳转到该路由 &#125;) &#125; &#125; else &#123; next(); &#125;&#125;) to.meta中是我们自定义的数据，其中就包括我们刚刚定义的requireAuth字段通过这个字段来判断该路由是否需要登录权限需要的话，同时当前应用不存在token，则跳转到登录页面，进行登录。登录成功后跳转到目标路由。 这种方式只是简单的前端路由控制，并不能阻止用户访问，假设有一种情况：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。这时候就需要结合 http 拦截器 + 后端接口返回的http 状态码来判断。 2.拦截器 要想统一处理所有http请求和响应，就得用上 axios 的拦截器。通过配置http response inteceptor，当后端接口返回401 Unauthorized（未授权），让用户重新登录。 12345678910111213141516171819202122232425262728293031// http request 拦截器axios.interceptors.request.use( config =&gt; &#123; if (stoken) &#123; // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `token $&#123;store.state.token&#125;`; &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, error =&gt; &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 返回 401 清除token信息并跳转到登录页面 router.replace(&#123; path: 'login', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;) &#125; &#125; return Promise.reject(error.response.data) // 返回接口返回的错误信息 &#125;);","tags":[{"name":"axios","slug":"axios","permalink":"http://zhaokunming.xyz/tags/axios/"},{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"}]},{"title":"随笔：《人间失格》","date":"2018-11-22T03:38:25.000Z","path":"2018/11/22/《人间失格》/","text":"很久之前就听说过这本书了，至于为什么对这本书记忆深刻，大概因为它的名字。 “人间失格”，之前并不知道这个词语的真正意思，我单纯的从字面上理解的话，认为这是一本描绘人世间晦暗面的故事合集。每每路过书店寻书买书，也是每每看到这本书的封面，可竟看不到书皮上的简介，之后又被其它的书所吸引，所以对于这本书认识也就一拖再拖。 最近一段时间也是有了一些空闲，突然间就想起了这本书，本来是要去书店买书来看的，可最近实体书店的数量在急剧减少，想找到一家真正为读者卖书的书店实在是难于上青天。就网上找来看了。我先去找了这本书的名字，才发现又被译为《丧失为人的资格》，突然间就感觉沉重了许多。 太宰治创作的中篇小说，不是很长，也可能是读起来容易让人忘记时间，利用了两天的午休时间读完了。通过叶藏的经历，我看到的是他内心的无名恐惧是如何一步一步地拖向命运的深渊，一个神经症人格在自我救赎与命运搏斗之间的痛苦挣扎。虽然，叶藏的结局挺惨的，但却给我的精神上有种难以形容的震憾。 读过之后沉默了一段时间，想了些东西，想写下来，却又不知道怎么写。我该怎样度过我的短短几十年，才算不辜负来人间一趟？我想给自己最大程度的自由，想要不安于现状又懂得满足，不做自己后悔的事，不给生活留有遗憾。这就是我计划的人生！我之后去查了太宰治的简介，《人间失格》作为一篇半自传的小说，阿叶的一生，又或者说太宰治的一生无疑是不幸的，感慨的同时又想，这世上又有多少人能说自己是幸运的呢？ 小说中主人公看待世界的目光，使我看到了一个更加光怪陆离的世界，我读书中的故事大多是选择愿意去相信的，相信这世界的某个角落正在或者已经发生了书中的故事，无论是美好的还是悲伤的。就像吃橘子期待者下一口是甜的还是酸的，不论什么味道的，都尝到了味道，即使吐掉，味道也已经渗透到了舌尖。 这本书我是不怎么建议人们去读的，如果让人们丧失了对生活中美好的向往，那么想必生命的意义对于他们也就不存在了吧。但这并不是说这本书丧失了它的艺术价值，如果你的内心并不晴朗，那么缓些日子再来阅读《人间失格》吧。 摘录： 1、相互轻蔑却又彼此来往 并一起自我作贱——这就是世上所谓“朋友”的真面目。 2、胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还被幸福所伤。 3、所谓世人，不就是你吗？ 4、人啊，明明一点儿也不了解对方，错看对方，却视彼此为独一无二的挚友，一生不解对方的真性情，待一方撒手西去，还要为其哭泣，念诵悼词。 5、若能避开猛烈的狂喜，自然不会有悲痛来袭。 6、我的不幸，恰恰在于我缺乏拒绝的能力。我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。 7、唯有尽力自持，方不致癫狂。 8、因为怯懦，所以逃避生命，以不抵抗在最黑暗的沉沦中生出骄傲，因为骄傲，所以不选择生，所以拒斥粗鄙的乐观主义。 9、如今的我，谈不上幸福，也谈不上不幸。一切都会过去的。在所谓“人世间”摸爬滚打至今，我唯一愿意视为真理的，就只有这一句话：一切都会过去的。 10、因为我更像一个丑陋的怪物，虽然很想普普通通地活得像个人，但社会却一直将我当做一个怪物。 11、我急切地盼望着可以经历一场放纵的快乐，纵使巨大的悲哀将接踵而至，我也在所不惜。 12、我知道有人是爱我的，但我好像缺乏爱人的能力。 13、我的不幸，恰恰在于我缺乏拒绝的能力。 14、我害怕一旦拒绝别人，便会在彼此心里留下永远无法愈合的裂痕。 15、这世上不幸的人各式各样——不，毫不夸张地说，这世上尽是不幸的人。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://zhaokunming.xyz/tags/%E9%9A%8F%E7%AC%94/"},{"name":"杂谈","slug":"杂谈","permalink":"http://zhaokunming.xyz/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"宏任务、微任务以及Event-Loop","date":"2018-09-05T02:58:35.000Z","path":"2018/09/05/宏任务、微任务以及Event-Loop/","text":"首先，JavaScript是一个单线程的脚本语言。 所以就是说在一行代码执行的过程中，必然不会存在同时执行的另一行代码，就像使用alert()以后进行疯狂console.log，如果没有关闭弹框，控制台是不会显示出一条log信息的。 亦或者有些代码执行了大量计算，比方说在前端暴力破解密码之类的鬼操作，这就会导致后续代码一直在等待，页面处于假死状态，因为前边的代码并没有执行完。 所以如果全部代码都是同步执行的，这会引发很严重的问题，比方说我们要从远端获取一些数据，难道要一直循环代码去判断是否拿到了返回结果么？就像去饭店点餐，肯定不能说点完了以后就去后厨催着人炒菜的，会被揍的。 于是就有了异步事件的概念，注册一个回调函数，比如说发一个网络请求，我们告诉主程序等到接收到数据后通知我，然后我们就可以去做其他的事情了。 然后在异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，可以去执行。 比如说打了个车，如果司机先到了，但是你手头还有点儿事情要处理，这时司机是不可能自己先开着车走的，一定要等到你处理完事情上了车才能走。 微任务与宏任务的区别 这个就像去银行办业务一样，先要取号进行排号。一般上边都会印着类似：“您的号码为XX，前边还有XX人。”之类的字样。 因为柜员同时职能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。 所以多个宏任务合在一起就可以认为说有一个任务队列在这，里边是当前银行中所有排号的客户。 任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中，就像在银行中排号，如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号 而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。 所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。 也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？ 无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。 这就说明：你大爷永远是你大爷 在当前的微任务没有执行完成时，是不会执行下一个宏任务的。 所以就有了那个经常在面试题、各种博客中的代码片段： 12345678910setTimeout(_ =&gt; console.log(4))new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then(_ =&gt; &#123; console.log(3)&#125;)console.log(2) setTimeout就是作为宏任务来存在的，而Promise.then则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。 所有会进入的异步都是指的事件回调中的那部分代码 也就是说new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。 在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。所以就得到了上述的输出结论1、2、3、4。 +部分表示同步执行的代码 123456789101112+setTimeout(_ =&gt; &#123;- console.log(4)+&#125;)+new Promise(resolve =&gt; &#123;+ resolve()+ console.log(1)+&#125;).then(_ =&gt; &#123;- console.log(3)+&#125;)+console.log(2) 本来setTimeout已经先设置了定时器（相当于取号），然后在当前进程中又添加了一些Promise的处理（临时添加业务）。 所以进阶的，即便我们继续在Promise中实例化Promise，其输出依然会早于setTimeout的宏任务： 1234567891011121314151617setTimeout(_ =&gt; console.log(4))new Promise(resolve =&gt; &#123; resolve() console.log(1)&#125;).then(_ =&gt; &#123; console.log(3) Promise.resolve().then(_ =&gt; &#123; console.log('before timeout') &#125;).then(_ =&gt; &#123; Promise.resolve().then(_ =&gt; &#123; console.log('also before timeout') &#125;) &#125;)&#125;)console.log(2) 当然了，实际情况下很少会有简单的这么调用Promise的，一般都会在里边有其他的异步操作，比如fetch、fs.readFile之类的操作。而这些其实就相当于注册了一个宏任务，而非是微任务。 P.S. 在Promise/A+的规范中，Promise的实现可以是微任务，也可以是宏任务，但是普遍的共识表示(至少Chrome是这么做的)，Promise应该是属于微任务阵营的 所以，明白哪些操作是宏任务、哪些是微任务就变得很关键，这是目前业界比较流行的说法： 宏任务 有些地方会列出来UI Rendering，说这个也是宏任务，可是在读了HTML规范文档以后，发现这很显然是和微任务平行的一个操作步骤 requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行 Event-Loop是个啥 上边一直在讨论 宏任务、微任务，各种任务的执行。 但是回到现实，JavaScript是一个单进程的语言，同一时间不能处理多个任务，所以何时执行宏任务，何时执行微任务？我们需要有这样的一个判断逻辑存在。 每办理完一个业务，柜员就会问当前的客户，是否还有其他需要办理的业务。（检查还有没有微任务需要处理）而客户明确告知说没有事情以后，柜员就去查看后边还有没有等着办理业务的人。（结束本次宏任务、检查还有没有宏任务需要处理） 这个检查的过程是持续进行的，每完成一个任务都会进行一次，而这样的操作就被称为Event Loop。(这是个非常简易的描述了，实际上会复杂很多) 而且就如同上边所说的，一个柜员同一时间只能处理一件事情，即便这些事情是一个客户所提出的，所以可以认为微任务也存在一个队列，大致是这样的一个逻辑： 1234567891011121314151617181920212223242526272829const macroTaskList = [ ['task1'], ['task2', 'task3'], ['task4'],]for (let macroIndex = 0; macroIndex &lt; macroTaskList.length; macroIndex++) &#123; const microTaskList = macroTaskList[macroIndex] for (let microIndex = 0; microIndex &lt; microTaskList.length; microIndex++) &#123; const microTask = microTaskList[microIndex] // 添加一个微任务 if (microIndex === 1) microTaskList.push('special micro task') // 执行任务 console.log(microTask) &#125; // 添加一个宏任务 if (macroIndex === 2) macroTaskList.push(['special macro task'])&#125;// &gt; task1// &gt; task2// &gt; task3// &gt; special micro task// &gt; task4// &gt; special macro task 之所以使用两个for循环来表示，是因为在循环内部可以很方便的进行push之类的操作（添加一些任务），从而使迭代的次数动态的增加。 以及还要明确的是，Event Loop只是负责告诉你该执行那些任务，或者说哪些回调被触发了，真正的逻辑还是在进程中执行的。 在浏览器中的表现 在上边简单的说明了两种任务的差别，以及Event Loop的作用，那么在真实的浏览器中是什么表现呢？ 首先要明确的一点是，宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤） I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。 假设有这样的一些DOM结构： 123456789101112131415&lt;style&gt; #outer &#123; padding: 20px; background: #616161; &#125; #inner &#123; width: 100px; height: 100px; background: #757575; &#125;&lt;/style&gt;&lt;div id=\"outer\"&gt; &lt;div id=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223const $inner = document.querySelector('#inner')const $outer = document.querySelector('#outer')function handler () &#123; console.log('click') // 直接输出 Promise.resolve().then(_ =&gt; console.log('promise')) // 注册微任务 setTimeout(_ =&gt; console.log('timeout')) // 注册宏任务 requestAnimationFrame(_ =&gt; console.log('animationFrame')) // 注册宏任务 $outer.setAttribute('data-random', Math.random()) // DOM属性修改，触发微任务&#125;new MutationObserver(_ =&gt; &#123; console.log('observer')&#125;).observe($outer, &#123; attributes: true&#125;)$inner.addEventListener('click', handler)$outer.addEventListener('click', handler) 如果点击#inner，其执行顺序一定是：click -&gt; promise -&gt; observer -&gt; click -&gt; promise -&gt; observer -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 因为一次I/O创建了一个宏任务，也就是说在这次任务中会去触发handler。 按照代码中的注释，在同步的代码已经执行完以后，这时就会去查看是否有微任务可以执行，然后发现了Promise和MutationObserver两个微任务，遂执行之。 因为click事件会冒泡，所以对应的这次I/O会触发两次handler函数(一次在inner、一次在outer)，所以会优先执行冒泡的事件(早于其他的宏任务)，也就是说会重复上述的逻辑。 在执行完同步代码与微任务以后，这时继续向后查找有木有宏任务。 需要注意的一点是，因为我们触发了setAttribute，实际上修改了DOM的属性，这会导致页面的重绘，而这个set的操作是同步执行的，也就是说requestAnimationFrame的回调会早于setTimeout所执行。 一些小惊喜 使用上述的示例代码，如果将手动点击DOM元素的触发方式变为$inner.click()，那么会得到不一样的结果。在Chrome下的输出顺序大致是这样的：click -&gt; click -&gt; promise -&gt; observer -&gt; promise -&gt; animationFrame -&gt; animationFrame -&gt; timeout -&gt; timeout。 与我们手动触发click的执行顺序不一样的原因是这样的，因为并不是用户通过点击元素实现的触发事件，而是类似dispatchEvent这样的方式，我个人觉得并不能算是一个有效的I/O，在执行了一次handler回调注册了微任务、注册了宏任务以后，实际上外边的$inner.click()并没有执行完。 所以在微任务执行之前，还要继续冒泡执行下一次事件，也就是说触发了第二次的handler。所以输出了第二次click，等到这两次handler都执行完毕后才会去检查有没有微任务、有没有宏任务。 两点需要注意的： .click()的这种触发事件的方式个人认为是类似dispatchEvent，可以理解为同步执行的代码 123456789document.body.addEventListener('click', _ =&gt; console.log('click'))document.body.click()document.body.dispatchEvent(new Event('click'))console.log('done')// &gt; click// &gt; click// &gt; done MutationObserver的监听不会说同时触发多次，多次修改只会有一次回调被触发。 123456789101112new MutationObserver(_ =&gt; &#123; console.log('observer') // 如果在这输出DOM的data-random属性，必然是最后一次的值，不解释了&#125;).observe(document.body, &#123; attributes: true&#125;)document.body.setAttribute('data-random', Math.random())document.body.setAttribute('data-random', Math.random())document.body.setAttribute('data-random', Math.random())// 只会输出一次 ovserver 这就像去饭店点餐，服务员喊了三次，XX号的牛肉面，不代表她会给你三碗牛肉面。上述观点参阅自Tasks, microtasks, queues and schedules，文中有动画版的讲解 在Node中的表现 Node也是单线程，但是在处理Event Loop上与浏览器稍微有些不同，这里是Node官方文档的地址。 就单从API层面上来理解，Node新增了两个方法可以用来使用：微任务的process.nextTick以及宏任务的setImmediate。 setImmediate与setTimeout的区别 在官方文档中的定义，setImmediate为一次Event Loop执行完毕后调用。 setTimeout则是通过计算一个延迟时间后进行执行。 但是同时还提到了如果在主进程中直接执行这两个操作，很难保证哪个会先触发。 因为如果主进程中先注册了两个任务，然后执行的代码耗时超过XXs，而这时定时器已经处于可执行回调的状态了。 所以会先执行定时器，而执行完定时器以后才是结束了一次Event Loop，这时才会执行setImmediate。 12setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate')) 有兴趣的可以自己试验一下，执行多次真的会得到不同的结果。 但是如果后续添加一些代码以后，就可以保证setTimeout一定会在setImmediate之前触发了： 123456setTimeout(_ =&gt; console.log('setTimeout'))setImmediate(_ =&gt; console.log('setImmediate'))let countdown = 1e9while(countdonn--) &#123; &#125; // 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了，所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate` 如果在另一个宏任务中，必然是setImmediate先执行： 123456require('fs').readFile(__dirname, _ =&gt; &#123; setTimeout(_ =&gt; console.log('timeout')) setImmediate(_ =&gt; console.log('immediate'))&#125;)// 如果使用一个设置了延迟的setTimeout也可以实现相同的效果 process.nextTick 就像上边说的，这个可以认为是一个类似于Promise和MutationObserver的微任务实现，在代码执行的过程中可以随时插入nextTick，并且会保证在下一个宏任务开始之前所执行。 在使用方面的一个最常见的例子就是一些事件绑定类的操作： 1234567891011121314class Lib extends require('events').EventEmitter &#123; constructor () &#123; super() this.emit('init') &#125;&#125;const lib = new Lib()lib.on('init', _ =&gt; &#123; // 这里将永远不会执行 console.log('init!')&#125;) 因为上述的代码在实例化Lib对象时是同步执行的，在实例化完成以后就立马发送了init事件。而这时在外层的主程序还没有开始执行到lib.on(‘init’)监听事件的这一步。所以会导致发送事件时没有回调，回调注册后事件不会再次发送。 我们可以很轻松的使用process.nextTick来解决这个问题： 12345678910111213class Lib extends require('events').EventEmitter &#123; constructor () &#123; super() process.nextTick(_ =&gt; &#123; this.emit('init') &#125;) // 同理使用其他的微任务 // 比如Promise.resolve().then(_ =&gt; this.emit('init')) // 也可以实现相同的效果 &#125;&#125; 这样会在主进程的代码执行完毕后，程序空闲时触发Event Loop流程查找有没有微任务，然后再发送init事件。 关于有些文章中提到的，循环调用process.nextTick会导致报警，后续的代码永远不会被执行，这是对的，参见上边使用的双重循环实现的loop即可，相当于在每次for循环执行中都对数组进行了push操作，这样循环永远也不会结束 多提一嘴async/await函数 因为，async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种。所以在使用await关键字与Promise.then效果类似： 1234567891011setTimeout(_ =&gt; console.log(4))async function main() &#123; console.log(1) await Promise.resolve() console.log(3)&#125;main()console.log(2) async函数在await之前的代码都是同步执行的，可以理解为await之前的代码属于new Promise时传入的代码，await之后的所有代码都是在Promise.then中的回调","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"}]},{"title":"redux状态管理框架","date":"2018-06-20T06:02:07.000Z","path":"2018/06/20/redux状态管理框架/","text":"Redux对于JavaScript应用而言是一个可预测状态的容器。换言之，它是一个应用数据流框架，而不是传统的像underscore.js或者AngularJs那样的库或者框架。 Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。 redux 是一个范用的状态管理框架主要是解决了组件间状态共享的问题原理是集中式管理 不是所有的项目都需要使用redux 流程 View调用store.dispatch发起Action-&gt;store接受Action(action传入reducer函数,reducer函数返回一个新的state)-&gt;通知store.subscribe订阅的重新渲染函数 redux和flux的区别 Redux和Flux很像。主要区别在于Flux有多个可以改变应用状态的store，它通过事件来触发这些变化。组件可以订阅这些事件来和当前状态同步。 Redux没有分发器dispatcher，但在Flux中dispatcher被用来传递数据到注册的回调事件。另一个不同是Flux中有很多扩展是可用的，这也带来了一些混乱与矛盾 在redux当中只能定义一个可以更新状态的storeflux可以定义多个仓库redux把store和Dispatcher合并,结构更加简单清晰新增state,对状态的管理更加明确 redux和vuex的区别 改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可 redux的优点 redux把流程规范了，统一渲染根节点虽然对代码管理上规范了一些,只要有需要显示数据的组件，当相关数据更新时都会自动进行更新。减少手动编码量，提高编码效率。 redux的缺点 一个组件所需要的数据，当相关数据更新时，组件要重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 redux中有三个基本概念，Action，Reducer，Store。store 仓库 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器。 action 中发送过来的对象 必须有一个type属性reducer 他是一个纯函数 他会跟action发送过来的type类型做逻辑上的处理（使用switch方法进行判断） Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 约束：不得改写参数不能调用系统 I/O 的API不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 Redux核心API-reducer Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。 1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; Reducer拆分 12345import &#123;combineReducers&#125; from 'redux';Const reducer=combineReducers(&#123;Xxx:xxx(函数－业务逻辑)&#125;) Middleware的由来 在redux里，action仅仅是携带了数据的普通js对象。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发。 同步的情况下一切都很完美，但是reducer无法处理异步的情况。例如：我希望点击一个按钮，2秒之后更新视图，显示消息“Hi”。那么我们就需要在action和reducer中间架起一座桥梁来处理异步。这就是middleware。 参考代码： 123456export default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; typeof action === 'function' ? action(dispatch, getState) : next(action);&#125; 这段代码的意思是，中间件这个桥梁接受到的参数action，如果不是function则和过去一样直接执行next方法(下一步处理)。相当于中间件没有做任何事。如果action是function，则先执行action，action的处理结束之后，再在action的内部调用dispatch。 Redux异步流 redux-thunk： redux-saga redux-promisestore.dispatch参数可以是一个function 使用方法：1.引入：import thunk from ‘redux-thunk’; 2.加入中间件const store = createStore(fetchReducer, applyMiddleware(thunk)); 基本结构 展示视图组件： View:视图组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, &#123; Component &#125; from 'react';import Store from './Store';import Action from './Action';export default class View extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; list:Store.getState().todolist, str:Store.getState().todostr &#125; this.changeItem=this.changeItem.bind(this) &#125; changeItem()&#123; this.setState(&#123; list:Store.getState().todolist, str:Store.getState().todostr &#125;) &#125; componentDidMount()&#123; Store.subscribe(this.changeItem) &#125; add()&#123; Store.dispatch(Action.addItem(this.refs.ipt.value)) // console.log(this.refs.ipt.value) this.refs.ipt.value='' &#125; del(index)&#123; Store.dispatch(Action.delItem(index)) &#125; show()&#123; // Store.dispatch(Action.toShow(this.refs.ipt2.value)) Store.dispatch((dispatch)=&gt;&#123; let timer=null; if(timer!==null)return; timer=setTimeout(()=&gt;&#123; dispatch(Action.toShow(this.refs.ipt2.value)) this.refs.ipt2.value='' timer=null &#125;,2000) &#125;) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;hahaha视图层&lt;/h2&gt; &lt;input type=\"text\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.add()&#125;&gt;添加&lt;/button&gt; &#123; this.state.list.map((item,i)=&gt;&#123; return( &lt;div key=&#123;i&#125;&gt; &lt;p&gt;&#123;item&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.del(i)&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; ) &#125;) &#125; &lt;hr/&gt; &lt;input type=\"text\" ref=\"ipt2\"/&gt; &lt;button onClick=&#123;()=&gt;this.show()&#125;&gt;展示&lt;/button&gt; &#123; &lt;p&gt;&#123;this.state.str&#125;&lt;/p&gt; &#125; &lt;/div&gt; ) &#125;&#125; Action： 1234567891011121314151617181920212223var Action = &#123; addItem(msg)&#123; return&#123; type:'ADD', text:msg &#125; &#125;, delItem(index)&#123; return&#123; type:'DEL', text:index &#125; &#125;, toShow(msg)&#123; return&#123; type:'SHOW', text:msg &#125; &#125;&#125;export default Action; Store: 1234567import &#123;createStore,applyMiddleware&#125; from 'redux';import Reducer from './Reducer';import thunk from 'redux-thunk'var Store=createStore(Reducer,applyMiddleware(thunk))export default Store; Reducer: 12345678910111213141516171819202122232425262728293031import &#123;combineReducers&#125; from 'redux';import List from './List'import Str from './Str';//拆分reducer写法var Reducer=combineReducers(&#123; todolist:List, todostr:Str&#125;)//不拆分reducer写法// var Reducer = ((state=[],action)=&gt;&#123;// switch (action.type) &#123;// case \"ADD\":// let arr=[...state]// arr.push(action.text)// return arr// case \"DEL\":// let arrs=[...state]// arrs.splice(action.text,1)// return arrs// default:// return state// &#125;// &#125;)export default Reducer; 如果将Reducer拆分的话，拆分的模块可以放在同级目录下，通过import引入： 拆分出的List模块： 1234567891011121314151617var List=((state=[],action)=&gt;&#123; switch (action.type) &#123; case \"ADD\": let arr=[...state] arr.push(action.text) return arr case \"DEL\": let arsr=[...state] arsr.splice(action.text,1) return arsr default: return state &#125;&#125;)export default List; 拆分出的Str模块： 12345678910111213var Str=((state='',action)=&gt;&#123; switch (action.type) &#123; case 'SHOW': let strings=state strings=action.text return strings default: return state &#125;&#125;)export default Str; 合并写法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React,&#123;Component&#125; from 'react';import &#123;Map&#125; from 'immutable'import &#123;createStore&#125; from 'redux'const user=Map(&#123;name:''&#125;)const Action=&#123; taps(msg)&#123; return&#123; type:\"SAVE\", text:msg &#125; &#125;&#125;const Reducer=(state=user,action)=&gt;&#123; switch (action.type) &#123; case \"SAVE\": let names=state.set('name',action.text) return names; default: return state &#125;&#125;const Store=createStore(Reducer)class App extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; str:Store.getState().get('name') &#125; this.change=this.change.bind(this) &#125; tap()&#123; Store.dispatch(Action.taps(this.refs.ipt.value)) this.refs.ipt.value=\"\" &#125; change()&#123; this.setState(&#123; str:Store.getState().get('name') &#125;) &#125; componentDidMount()&#123; Store.subscribe(this.change) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;immutable&lt;/h2&gt; &lt;h2&gt;&#123;this.state.str&#125;&lt;/h2&gt; &lt;input type=\"text\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.tap()&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App;","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://zhaokunming.xyz/tags/redux/"}]},{"title":"flux状态管理器","date":"2018-05-25T01:24:10.000Z","path":"2018/05/25/flux状态管理器/","text":"Flux是Facebook用来构建客户端Web应用的应用架构。它利用单向数据流的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux。 四个组成部分 View： 视图层 Action（动作）：视图层发出的消息（比如click） 调用 dispatch方法发数据 Dispatcher（派发器）：用来接收Actions、执行回调函数-register 方法接收 Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面 流程： 1、用户访问 View2、View 发出用户的 Action3、Dispatcher 收到 Action，要求 Store 进行相应的更新4、Store 更新后，发出一个”change”事件5、View 收到”change”事件后，更新页面 dispatcher与action dispatcher是事件调度中心，flux模型的中心枢纽，管理着Flux应用中的所有数据流。它本质上是Store的回调注册。每个Store注册它自己并提供一个回调函数。当Dispatcher响应Action时，通过已注册的回调函数，将Action提供的数据负载发送给应用中的所有Store。应用层级单例 store Store中包含应用所有的数据 Store是应用中唯一的数据发生变更的地方 Store中没有赋值接口—所有数据变更都是由dispatcher发送到store，新的数据随着Store触发的change事件传回view。Store对外只暴露getter，不允许提供setter！！禁止在任何地方直接操作Store。 controller-view controller-view 可以理解成MVC模型中的controller，它一般由应用的顶层容器充当，负责从store中获取数据并将数据传递到子组件中。简单的应用一般只有一个controller-view，复杂应用中也可以有多个。controller-view是应用中唯一可以操作state的地方(setState()) view view(UI组件) ui-component 职责单一只允许调用action触发事件，数据从由上层容器通过属性传递过来。 actionCreator actionCreators是相对独立的，它作为语法上的辅助函数以action的形式使得dispatcher传递数据更为便利 flux核心api Action为对象方法 接收view的响应方法内部响应dispatcher对象的dispatch方法 Dispatch对象 由 flux对象引入Dispatcher对象 创建 Dispatch对象 new Dispatcher（）响应action的dispatch 方法 在dispatch对象中使用 register注册回调接收数据Dispatch.register((action)=&gt;{}) action参数为Action对象方法提供的数据判断符合条件 调用store的相应处理方法以及change事件 Store中change事件的触发通过this.emit 监听改变通过 this.on() 使用的是events模块中EventEmitter对象拷贝属性方法使用 object-assign 原生js依赖中的 assign对象 顶层容器中调用store的获取数据 以及在dom加载完成函数中调用store监听 环境搭建： 1npm install create-react-app -g 1create-react-app xxx(项目名) 安装依赖： 1npm i flux --save-dev 目标目录： TodoController:顶层容器 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from 'react';import View from './View';import Action from './Action'import Dispatch from './Dispatch'import Store from './Store'export default class TodoController extends Component&#123; constructor(props)&#123; super(props) this.state=&#123; list:Store.getall() &#125; this.changeitem=this.changeitem.bind(this) //注意this指向 &#125; changeitem()&#123; this.setState(&#123;list:Store.getall()&#125;) &#125; addItem(msg)&#123; console.log(msg) Dispatch.dispatch(Action.addItem(msg)) // let arr=this.state.list // arr.push(msg) // this.setState(&#123; // list:arr // &#125;) &#125; delItem(index)&#123; console.log(index) Dispatch.dispatch(Action.delItem(index)) &#125; componentDidMount()&#123; Store.listenchange(this.changeitem) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;顶层容器&lt;/h2&gt; &lt;View title=&#123;(msg)=&gt;this.addItem(msg)&#125; list=&#123;this.state.list&#125; some=&#123;(index)=&gt;this.delItem(index)&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 根组件App.js中引入，展示视图 View：视图 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';export default class View extends Component&#123; constructor(props)&#123; super(props) &#125; add()&#123; console.log(this.refs.ipt.value) this.props.title(this.refs.ipt.value) this.refs.ipt.value='' &#125; del(index)&#123; this.props.some(index) &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;视图层&lt;/h2&gt; &lt;input type=\"text\" defaultValue=\"todolist\" ref=\"ipt\"/&gt; &lt;button onClick=&#123;()=&gt;this.add()&#125;&gt;添加&lt;/button&gt; &#123; this.props.list.map((item,i)=&gt;&#123; return( &lt;div key=&#123;i&#125;&gt; &lt;p&gt;&#123;item&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;this.del(i)&#125;&gt;删除&lt;/button&gt; &lt;/div&gt; ) &#125;) &#125; &lt;/div&gt; ) &#125;&#125; Action:处理分类数据 12345678910111213141516var Action=&#123; addItem(msg)&#123; return&#123; actionType:'ADD', text:msg &#125; &#125;, delItem(index)&#123; return&#123; actionType:'DEL', text:index &#125; &#125;&#125;export default Action; Dispatch:接收数据 1234567891011121314151617import &#123;Dispatcher&#125; from 'flux'import Store from './Store'var Dispatch=new Dispatcher();Dispatch.register((action)=&gt;&#123; switch (action.actionType)&#123; case \"ADD\": //命令store进行数据变更 Store.add(action.text) Store.change() break; case \"DEL\": Store.del(action.text) Store.change() break; &#125;&#125;)export default Dispatch; Store:操作数据 1234567891011121314151617181920212223import &#123;EventEmitter&#125; from 'events';import assign from 'object-assign';var Store=assign(&#123;&#125;,EventEmitter.prototype,&#123; Todos:[], add(msg)&#123; this.Todos.push(msg) &#125;, change()&#123; this.emit('change') &#125;, listenchange(callback)&#123; this.on('change',callback) &#125;, getall()&#123; return this.Todos &#125;, del(index)&#123; this.Todos.splice(index,1) &#125;&#125;)export default Store;","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"flux","slug":"flux","permalink":"http://zhaokunming.xyz/tags/flux/"}]},{"title":"web前端性能优化","date":"2018-05-01T08:59:06.000Z","path":"2018/05/01/性能优化/","text":"Web前端性能优化——如何提高页面加载速度 前言： 在同样的网络环境下，两个同样能满足你的需求的网站，一个“Duang”的一下就加载出来了，一个纠结了半天才出来，你会选择哪个？研究表明：用户最满意的打开网页时间是2-5秒，如果等待超过10秒，99%的用户会关闭这个网页。也许这样讲，各位还不会有太多感触，接下来我列举一组数据：Google网站访问速度每慢400ms就导致用户搜索请 求下降0.59%;Amazon每增加100ms网站延迟将导致收入下降1%;雅虎如果有400ms延迟会导致流量下降5-9%。网站的加载速度严重影响了用户体验，也决定了这个网站的生死存亡。 可能有人会说：网站的性能是后端工程师的事情，与前端并无多大关系。我只能说，too young too simple。事实上，只有10%~20%的最终用户响应时间是用在从Web服务器获取HTML文档并传送到浏览器的，那剩余的时间去哪儿了？来瞄一下性能黄金法则： 只有10% ~ 20%的最终用户响应时间花在了下载HTML文档上。其余的80% ~ 90%时间花在了下载页面中的所有组件上。 接下来我们将研究一下前端攻城狮如何来提高页面的加载速度。 一、减少HTTP请求 上面说到80%~90%时间花在了下载页面中的所有组件进行的HTTP请求上。因此，改善响应时间最简单的途径就是减少HTTP请求的数量。 图片地图： 假设导航栏上有五幅图片，点击每张图片都会进入一个链接，这样五张导航的图片在加载时会产生5个HTTP请求。然而，使用一个图片地图可以提高效率，这样就只需要一个HTTP请求。 服务器端图片地图：将所有点击提交到同一个url，同时提交用户点击的x、y坐标，服务器端根据坐标映射响应 客户端图片地图：直接将点击映射到操作 12345678&lt;img src=\"planets.jpg\" border=\"0\" usemap=\"#planetmap\" alt=\"Planets\" /&gt;&lt;map name=\"planetmap\" id=\"planetmap\"&gt; &lt;area shape=\"rect\" coords=\"180,139,14\" href =\"venus.html\" alt=\"Venus\" /&gt; &lt;area shape=\"rect\" coords=\"129,161,10\" href =\"mercur.html\" alt=\"Mercury\" /&gt; &lt;area shape=\"rect\" coords=\"0,0,110,260\" href =\"sun.html\" alt=\"Sun\" /&gt; &lt;area shape=\"rect\" coords=\"140,0,110,260\" href =\"star.html\" alt=\"Sun\" /&gt;&lt;/map&gt; 使用图片地图的缺点：指定坐标区域时，矩形或圆形比较容易指定，而其它形状手工指定比较难 CSS Sprites CSS Sprites地址推荐 CSS Sprites直译过来就是CSS精灵，但是这种翻译显然是不够的，其实就是通过将多个图片融合到一副图里面，然后通过CSS的一些技术布局到网页上。特别是图片特别多的网站，如果能用css sprites降低图片数量，带来的将是速度的提升。 1234567&lt;div&gt; &lt;span id=\"image1\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image2\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image3\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image4\" class=\"nav\"&gt;&lt;/span&gt; &lt;span id=\"image5\" class=\"nav\"&gt;&lt;/span&gt;&lt;/div&gt; 12345678910111213141516171819202122.nav &#123; width: 50px; height: 50px; display: inline-block; border: 1px solid #000; background-image: url('E:/1.png');&#125;#image1 &#123; background-position: 0 0;&#125;#image2 &#123; background-position: -95px 0;&#125;#image3 &#123; background-position: -185px 0;&#125;#image4 &#123; background-position: -275px 0;&#125;#image5 &#123; background-position: -366px -3px;&#125; 运行结果： PS：使用CSS Sprites还有可能降低下载量，可能大家会认为合并后的图片会比分离图片的总和要大，因为还有可能会附加空白区域。实际上，合并后的图片会比分离的图片总和要小，因为它降低了图片自身的开销，譬如颜色表、格式信息等。 字体图标 在可以大量使用字体图标的地方我们可以尽可能使用字体图标，字体图标可以减少很多图片的使用，从而减少http请求，字体图标还可以通过CSS来设置颜色、大小等样式，何乐而不为。 合并脚本 和样式表 将多个样式表或者脚本文件合并到一个文件中，可以减少HTTP请求的数量从而缩短效应时间。 然而合并所有文件对许多人尤其是编写模块化代码的人来说是不能忍的，而且合并所有的样式文件或者脚本文件可能会导致在一个页面加载时加载了多于自己所需要的样式或者脚本，对于只访问该网站一个（或几个）页面的人来说反而增加了下载量，所以大家应该自己权衡利弊。 二、使用CDN 如果应用程序web服务器离用户更近，那么一个HTTP请求的响应时间将缩短。另一方面，如果组件web服务器离用户更近，则多个HTTP请求的响应时间将缩短。 CDN（内容发布网络）是一组分布在多个不同地理位置的Web服务器，用于更加有效地向用户发布内容。在优化性能时，向特定用户发布内容的服务器的选择基于对网络慕课拥堵的测量。例如，CDN可能选择网络阶跃数最小的服务器，或者具有最短响应时间的服务器。 CDN还可以进行数据备份、扩展存储能力，进行缓存，同时有助于缓和Web流量峰值压力。 CDN的缺点： 1、响应时间可能会受到其他网站流量的影响。CDN服务提供商在其所有客户之间共享Web服务器组。2、如果CDN服务质量下降了，那么你的工作质量也将下降3、无法直接控制组件服务器 三、添加Expires头 页面的初次访问者会进行很多HTTP请求，但是通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。 Web服务器通过Expires头告诉客户端可以使用一个组件的当前副本，直到指定的时间为止。例如： Expires: Fri, 18 Mar 2016 07:41:53 GMT Expires缺点： 它要求服务器和客户端时钟严格同步；过期日期需要经常检查 HTTP1.1中引入Cache-Control来克服Expires头的限制，使用max-age指定组件被缓存多久。 Cache-Control： max-age=12345600 若同时制定Cache-Control和Expires，则max-age将覆盖Expires头 四、压缩组件 从HTTP1.1开始，Web客户端可以通过HTTP请求中的Accept-Encoding头来表示对压缩的支持 Accept-Encoding: gzip,deflate 如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来进行压缩。Web服务器通过响应中的Content-Encoding来通知 Web客户端。 Content-Encoding: gzip 代理缓存 当浏览器通过代理来发送请求时，情况会不一样。假设针对某个URL发送到代理的第一个请求来自于一个不支持gzip的浏览器。这是代理的第一个请求，缓存为空。代理将请求转发给服务器。此时响应是未压缩的，代理缓存同时发送给浏览器。现在，假设到达代理的请求是同一个url，来自于一个支持gzip的浏览器。代理会使用缓存中未压缩的内容进行响应，从而失去了压缩的机会。相反，如果第一个浏览器支持gzip，第二个不支持，你们代理缓存中的压缩版本将会提供给后续的浏览器，而不管它们是否支持gzip。 解决办法：在web服务器的响应中添加vary头Web服务器可以告诉代理根据一个或多个请求头来改变缓存的响应。因为压缩的决定是基于Accept-Encoding请求头的，因此需要在vary响应头中包含Accept-Encoding。 vary: Accept-Encoding 五、将样式表放在头部 首先说明一下，将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。 我们总是希望页面能够尽快显示内容，为用户提供可视化的回馈，这对网速慢的用户来说是很重要的。 将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西 六、将脚本放在底部 更样式表相同，脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。 js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。 下载脚本时并行下载是被禁用的——即使使用了不同的主机名，也不会启用其他的下载。因为脚本可能修改页面内容，因此浏览器会等待；另外，也是为了保证脚本能够按照正确的顺序执行，因为后面的脚本可能与前面的脚本存在依赖关系，不按照顺序执行可能会产生错误。 七、避免CSS表达式 CSS表达式是动态设置CSS属性的一种强大并且危险的方式，它受到了IE5以及之后版本、IE8之前版本的支持。 12345p &#123; width: expression(func(),document.body.clientWidth &gt; 400 ? \"400px\" : \"auto\"); height: 80px; border: 1px solid #f00;&#125; 12345678910111213&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var n = 0; function func() &#123; n++; // alert(); console.log(n); &#125;&lt;/script&gt; 鼠标移动了几次，函数的运行次数轻而易举的达到了几千次，危险性显而易见。 如何解决： 一次性表达式： 12345p &#123; width: expression(func(this)); height: 80px; border: 1px solid #f00;&#125; 12345678910111213&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt; var n = 0; function func(elem) &#123; n++; elem.style.width = document.body.clientWidth &gt; 400 ? '400px' : \"auto\"; console.log(n); &#125;&lt;/script&gt; 事件处理机制 用js事件处理机制来动态改变元素的样式，使函数运行次数在可控范围之内。 八、使用外部的JavaScript和CSS 内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。 影响因素： 1、每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度。 2、如果你的网站不同的页面之间使用的组件大致相同，那么使用外部文件可以提高这些组件的重用率。 加载后下载 有时候我们希望内联样式和脚本，但又可以为接下来的页面提供外部文件。那么我们可以在页面加载完成止呕动态加载外部组件，以便用户接下来的访问。 12345678910111213141516171819202122232425function doOnload() &#123; setTimeout(\"downloadFile()\",1000); &#125; window.onload = doOnload; function downloadFile() &#123; downloadCss(\"http://abc.com/css/a.css\"); downloadJS(\"http://abc.com/js/a.js\"); &#125; function downloadCss(url) &#123; var ele = document.createElement('link'); ele.rel = \"stylesheet\"; ele.type = \"text/css\"; ele.href = url; document.body.appendChild(ele); &#125; function downloadJS(url) &#123; var ele = document.createElement('script'); ele.src = url; document.body.appendChild(ele); &#125; 在该页面中，JavaScript和CSS被加载两次（内联和外部）。要使其正常工作，必须处理双重定义。将这些组件放到一个不可见的IFrame中是一个比较好的解决方式。 九、减少DNS查找 当我们在浏览器的地址栏输入网址（譬如： www.baidu.com） ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？ 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户 域名解析是页面加载的第一步，那么域名是如何解析的呢？以Chrome为例： Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有 www.baidu.com 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束.注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\\Windows\\System32\\drivers\\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问 www.baidu.com 这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问 www.baidu.com 这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道 www.baidu.com 这个域名的IP地址，但是我知道 baidu.com 这个域的DNS地址，你去找它去，于是运营商的DNS又向 baidu.com 这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 www.baidu.com 这个域名的IP地址是多少？），这个时候 baidu.com 域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 www.baidu.com 这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 www.baidu.com 对应的IP地址，该进行一步的动作了。 注：一般情况下是不会进行以下步骤的 如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤：5. 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） 如果第6步也没有查询成功，那么客户端就要进行广播查找 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样） 如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？ 当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。 减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP 1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个），这样减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。 十、精简JavaScript 精简 精简就是从代码中移除不必要的字符以减少文件大小，降低加载的时间。代码精简的时候会移除不必要的空白字符（空格，换行、制表符），这样整个文件的大小就变小了。 混淆 混淆是应用在源代码上的另外一种方式，它会移除注释和空白符，同时它还会改写代码。在混淆的时候，函数和变量名将会被转换成更短的字符串，这时代码会更加精炼同时难以阅读。通常这样做是为了增加对代码进行反向工程的难度，这也同时提高了性能。 缺点： 混淆本身比较复杂，可能会引入错误。 需要对不能改变的符号做标记，防止JavaScript符号（譬如关键字、保留字）被修改。 混淆会使代码难以阅读，这使得在产品环境中调试问题更加困难。 在以上提到了关于用gzip之类的压缩方式来压缩文件，这边说明一下，就算使用gzip等方式来压缩文件，精简代码依然是有必要的。一般来说，压缩产生的节省是高于精简的，在生产环境中，精简和压缩同时使用能够最大限度的获得更多的节省。 CSS的精简 CSS的精简带来的节省一般来说是小于JavaScript精简的，因为CSS中注释和空白相对较少。 除了移除空白、注释之外，CSS可以通过优化来获得更多的节省： 合并相同的类； 移除不使用的类； 使用缩写，譬如 1234567891011121314151617181920212223.right &#123; color: #fff; padding-top: 0; margin: 0 10px; border: 1px solid #111&#125;.wrong &#123; color: #ffffff; padding-top: 0px; margin-top: 0; margin-bottom: 0; margin-left: 10px; margin-right: 10px; border-color: #111; border-width: 1px; border-style: solid;&#125; 上面.right是正确的的写法，颜色使用缩写，使用0代替0px，合并可以合并的样式。另外，在精简的时候其实样式最后一行的’；’也是可以省略的。 来看看精简的例子： 以上分别是jquery-2.0.3的学习版（未精简）和精简版，可见精简文件的大小比源文件小了155k，而且，在精简版中jquery还做了混淆，譬如用e代替window等，从而获得最大的节省。 十一、避免重定向 什么是重定向？ 重定向用于将用户从一个URL重新路由到另一个URL。 常用重定向的类型 301：永久重定向，主要用于当网站的域名发生变更之后，告诉搜索引擎域名已经变更了，应该把旧域名的的数据和链接数转移到新域名下，从而不会让网站的排名因域名变更而受到影响。 302：临时重定向，主要实现post请求后告知浏览器转移到新的URL。 304：Not Modified，主要用于当浏览器在其缓存中保留了组件的一个副本，同时组件已经过期了，这是浏览器就会生成一个条件GET请求，如果服务器的组件并没有修改过，则会返回304状态码，同时不携带主体，告知浏览器可以重用这个副本，减少响应大小。 重定向如何损伤性能? 当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载。 来看一个实际例子：对于ASP.NET webform开发来说，对于新手很容易犯一个错误，就是把页面的连接写成服务器控件后台代码里，例如用一个Button控件，在它的后台click事件中写上：Response.Redirect(“”)；然而这个Button的作用只是转移URL，这是非常低效的做法，因为点击Button后，先发送一个Post请求给服务器，服务器处理Response.Redirect(“”)后就发送一个302响应给浏览器，浏览器再根据响应的URL发送GET请求。正确的做法应该是在html页面直接使用a标签做链接，这样就避免了多余的post和重定向。 重定向的应用场景 跟踪内部流量 重定向经常用于跟踪用户流量的方向,当拥有一个门户主页的时候，同时想对用户离开主页后的流量进行跟踪，这时可以使用重定向。例如: 某网站主页新闻的链接地址 http://a.com/r/news ，点击该链接将产生301响应，其Location被设置为 http://news.a.com 。通过分析a.com的web服务器日志可以得知人们离开首页之后的去向。 我们知道重定向是如何损伤性能的，为了实现更好的效率，可以使用Referer日志来跟踪内部流量去向。每个HTTP请求都有一个Referer表示原始请求页(除了从书签打开或直接键入URL等操作)，记录下每个请求的Referer，就避免了向用户发送重定向，从而改善了响应时间。 跟踪出站流量 有时链接可能将用户带离你的网站，在这种情况下，使用Referer就不太现实了。 同样也可以使用重定向来解决跟踪出站流量问题。以百度搜索为例，百度通过将每个链接包装到一个302重定向来解决跟踪的问题，例如搜索关键字“前端性能优化”，搜索结果中的一个URL为 https://www.baidu.com/link?url=pDjwTfa0IAf_FRBNlw1qLDtQ27YBujWp9jPN4q0QSJdNtGtDBK3ja3jyyN2CgxR5aTAywG4SI6V1NypkSyLISWjiFuFQDinhpVn4QE-uLGG&amp;wd=&amp;eqid=9c02bd21001c69170000000556ece297 ，即使搜索结果并没有变，但这个字符串是动态改变的，暂时还不知道这里起到怎样的作用？（个人感觉：字符串中包含了待访问的网址，点击之后会产生302重定向，将页面转到目标页面（待修改，求大神们给我指正）） 除了重定向外，我们还可以选择使用信标(beacon)——一个HTTP请求，其URL中包含有跟踪信息。跟踪信息可以从信标Web服务器的访问日记中提取出来，信标通常是一个1px*1px的透明图片，不过204响应更优秀，因为它更小，从来不被缓存，而且绝不会改变浏览器的状态。 十二、删除重复脚本 在团队开发一个项目时，由于不同开发者之间都可能会向页面中添加页面或组件，因此可能相同的脚本会被添加多次。 重复的脚本会造成不必要的HTTP请求（如果没有缓存该脚本的话），并且执行多余的JavaScript浪费时间，还有可能造成错误。 如何避免重复脚本呢？ 形成良好的脚本组织。重复脚本有可能出现在不同的脚本包含同一段脚本的情况，有些是必要的，但有些却不是必要的，所以需要对脚本进行一个良好的组织。 实现脚本管理器模块。 例如： 123456789101112131415161718function insertScript($file) &#123; if(hadInserted($file)) &#123; return; &#125; exeInsert($file); if(hasDependencies($file)) &#123; $deps = getDependencies($file); foreach ($deps as $script) &#123; insertScript($script); &#125; echo \"&lt;script type='text/javascript' src='\".getVersion($file).\"'&gt;&lt;/script&gt;\"; &#125; &#125; 先检查是否插入过，如果插入过则返回。如果该脚本依赖其它脚本，则被依赖的脚本也会被插入。最后脚本被传送到页面，getVersion会检查脚本并返回追加了对应版本号的文件名，这样如果脚本的版本变化了，那么以前浏览器缓存的就会失效。 十三、配置ETag 以前浏览器缓存的就会失效。 什么是ETag？ 实体标签(EntityTag)是唯一标识了一个组件的一个特定版本的字符串，是web服务器用于确认缓存组件的有效性的一种机制，通常可以使用组件的某些属性来构造它。 条件GET请求 如果组件过期了，浏览器在重用它之前必须首先检查它是否有效。浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。 那么服务器是根据什么判断缓存是否还有效呢?有两种方式： ETag（实体标签）； 最新修改日期； 最新修改日期 原始服务器通过Last-Modified响应头来返回组件的最新修改日期。 举个栗子： 当我们不带缓存访问 www.google.com.hk 的时候，我们需要下载google的logo，这时会发送这样一个HTTP请求： Request： GET googlelogo_color_272x92dp.png HTTP 1.1Host: www.google.com.hk Response: HTTP 1.1 200 OKLast-Modified:Fri, 04 Sep 2015 22:33:08 GMT 当需要再次访问相同组件的时候，同时缓存已经过期，浏览器会发送如下条件GET请求： Request： GET googlelogo_color_272x92dp.png HTTP 1.1If-Modified-Since:Fri, 04 Sep 2015 22:33:08 GMTHost: www.google.com.hk Response: HTTP 1.1 304 Not Modified 实体标签 ETag提供了另外一种方式，用于检测浏览器缓存中的组件与原始服务器上的组件是否匹配。摘抄自书上的例子： 不带缓存的请求： Request： GET /i/yahoo/gif HTTP 1.1Host: us.yimg.com Response: HTTP 1.1 200 OKLast-Modified:Tue,12 Dec 200603:03:59 GMTETag:”10c24bc-4ab-457elc1f“ 再次请求相同组件: Request： GET /i/yahoo/gif HTTP 1.1Host: us.yimg.comIf-Modified-Since:Tue,12 Dec 200603:03:59 GMTIf-None-Match:”10c24bc-4ab-457elc1f“ Response: HTTP 1.1 304 Not Midified 为什么要引入ETag? ETag主要是为了解决Last-Modified无法解决的一些问题： 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET; 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒); 某些服务器不能精确的得到文件的最后修改时间。 ETag带来的问题 ETag的问题在于通常使用某些属性来构造它，有些属性对于特定的部署了网站的服务器来说是唯一的。当使用集群服务器的时候，浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求，ETag就会出现不匹配的状况。例如：使用inode-size-timestamp来生成ETag，文件系统使用inode存储文件类型、所有者、组和访问模式等信息，在多台服务器上，就算文件大小、权限、时间戳等都相同，inode也是不同的。 最佳实践 如果使用Last-Modified不会出现任何问题，可以直接移除ETag，google的搜索首页则没有使用ETag。 确定要使用ETag，在配置ETag的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用size-timestamp来生成时间戳。 十四、使Ajax可缓存 维基百科中这样定义Ajax： AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。Ajax的概念由杰西·詹姆士·贾瑞特所提出。 传统的Web应用允许用户端填写表单（form），当提交表单时就向Web服务器发送一个请求。服务器接收并处理传来的表单，然后送回一个新的网页，但这个做法浪费了许多带宽，因为在前后两个页面中的大部分HTML码往往是相同的。由于每次应用的沟通都需要向服务器发送请求，应用的回应时间依赖于服务器的回应时间。这导致了用户界面的回应比本机应用慢得多。 与此不同，AJAX应用可以仅向服务器发送并取回必须的数据，并在客户端采用JavaScript处理来自服务器的回应。因为在服务器和浏览器之间交换的数据大量减少（大约只有原来的5%）[来源请求],服务器回应更快了。同时，很多的处理工作可以在发出请求的客户端机器上完成，因此Web服务器的负荷也减少了。 类似于DHTML或LAMP，AJAX不是指一种单一的技术，而是有机地利用了一系列相关的技术。虽然其名称包含XML，但实际上数据格式可以由JSON代替，进一步减少数据量，形成所谓的AJAJ。而客户端与服务器也并不需要异步。一些基于AJAX的“派生／合成”式（derivative/composite）的技术也正在出现，如AFLAX。 Ajax的目地是为突破web本质的开始—停止交互方式，向用户显示一个白屏后重绘整个页面不是一种好的用户体验。 异步与即时 Ajax的一个明显的有点就是向用户提供了即时反馈，因为它异步的从后端web服务器请求信息。 用户是否需要等待的关键因素在于Ajax请求是被动的还是主动的。被动请求是为了将来来使用而预先发起的，主动请求是基于用户当前的操作而发起的 什么样的AJAX请求可以被缓存？ POST的请求，是不可以在客户端缓存的，每次请求都需要发送给服务器进行处理，每次都会返回状态码200。（可以在服务器端对数据进行缓存，以便提高处理速度） GET的请求，是可以（而且默认）在客户端进行缓存的，除非指定了不同的地址，否则同一个地址的AJAX请求，不会重复在服务器执行，而是返回304。 Ajax请求使用缓存 在进行Ajax请求的时候，可以选择尽量使用get方法，这样可以使用客户端的缓存，提高请求速度。 十四、减少cookie传输 一方面，cookie包含在每次请求和响应中，太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中传输的数据量。另一方面，对于某些静态资源的访问，如CSS、script等，发送cookie没有意义，可以考虑静态资源使用独立域名访问，避免请求静态资源时发送cookie，减少cookie传输次数。 十五、Javascript代码优化 (1). DOM a.HTML Collection（HTML收集器，返回的是一个数组内容信息） 在脚本中 document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合” 包括读取集合的 length属性、访问集合中的元素。 因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。 b. Reflow &amp; Repaint 除了上面一点之外， DOM操作还需要考虑浏览器的Reflow和Repaint ，因为这些都是需要消耗资源的。 (2). 慎用 with with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 (3). 避免使用 eval和 Function 每次 eval 或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。 eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。 Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。 此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。 (4). 减少作用域链查找 前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。 低效率的写法： 123456789&lt;span style=\"font-size:14px;\"&gt;// 全局变量 var globalVar = 1; function myCallback(info)&#123; for( var i = 100000; i--;)&#123; //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 globalVar += i; &#125; &#125; &lt;/span&gt; 更高效的写法： 1234567891011121314&lt;span style=\"font-size:14px;\"&gt;// 全局变量 var globalVar = 1; function myCallback(info)&#123; //局部变量缓存全局变量 var localVar = globalVar; for( var i = 100000; i--;)&#123; //访问局部变量是最快的 localVar += i; &#125; //本例中只需要访问 2次全局变量 在函数中只需要将 globalVar中内容的值赋给localVar 中 globalVar = localVar; &#125; &lt;/span&gt; 此外，要减少作用域链查找还应该减少闭包的使用。 (5). 数据访问 Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量： a. 对任何对象属性的访问超过 1次 b. 对任何数组成员的访问次数超过 1次 另外，还应当尽可能的减少对对象以及数组深度查找。 (6). 字符串拼接 在 Javascript中使用”+”号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。 十六、CSS选择符优化 在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如 #toc A { color: #444; } 这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项。 十七、尽量少用iframe 在写网页的时候，我们可能会用到iframe，iframe的好处是它完全独立于父文档。iframe中包含的JavaScript文件访问其父文档是受限的。例如，来自不同域的iframe不能访问其父文档的Cookie。 开销最高的DOM元素 通常创建iframe元素的开销要比创建其它元素的开销高几十倍甚至几百倍。 iframe阻塞onload事件 通常我们会希望window.onload事件能够尽可能触发，原因如下： 1、我们可能在onload事件处理函数中编写了用于初始化UI的代码；2、onload事件触发时，浏览器停止“忙指示器”，并向用户反馈页面已经准备就绪。3、部分低版本浏览器（IE6、IE7、IE8、Safari3、Safari4、Chrome1、Chrome2等）只有onload事件触发之后才会触发unload事件。有时，我们会把一些重要的操作和window的unload事件绑定在一起。例如，减少内存泄露的代码。如果onload花费时间太长，用户可能会离开页面，那么在这些浏览器中unload可能就永远不会执行了。 通常情况下，iframe中的内容对页面来说不是很重要的（譬如第三方的广告），我们不应该因为这些内容而延迟window.onload事件的触发。 综上，即使iframe是空的，其开销也会很高，而且他会阻塞onload事件。所以，我们应该尽可能避免iframe的使用。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://zhaokunming.xyz/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"withRouter的作用","date":"2018-04-18T12:35:03.000Z","path":"2018/04/18/withRouter的作用和一个简单应用/","text":"withRouter的作用和一个简单应用 作用： 把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 一：如何使用withRouter： 比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下：设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 二：介绍一个简单应用 可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 图片显示不出来，所以我描述一下情况： 点击指定的路由跳转，doument.title属性，即页面标签头的值变为指定title","tags":[{"name":"react","slug":"react","permalink":"http://zhaokunming.xyz/tags/react/"},{"name":"withRouter","slug":"withRouter","permalink":"http://zhaokunming.xyz/tags/withRouter/"},{"name":"title设置","slug":"title设置","permalink":"http://zhaokunming.xyz/tags/title%E8%AE%BE%E7%BD%AE/"}]},{"title":"css3自适应法宝","date":"2018-02-03T04:17:33.000Z","path":"2018/02/03/css3自适应法宝/","text":"css3自适应法宝fill-available、fit-content、max-content、min-content fill-available fill-available表示撑满可用空间（包括高度，宽度），下面举个例子： 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; width: 60%; height: 500px; border: 1px solid #f00; margin: 20px auto 0; &#125; .son&#123; width: -webkit-fill-available; background: #ff0; height:200px;/*高也可以是fill-available*/ &#125; &lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fill-available对于行内块（inline-block）和块元素（block）起作用,这个要注意哦，等高布局就更简单了 12345678910111213141516&lt;style type=\"text/css\"&gt; .box&#123; height: 200px; &#125; .son&#123; width: 30%; height: -webkit-fill-available; background: #f00; display: inline-block; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt; fit-content fit-content表示宽度缩小到内容的宽度，下面have a 栗子 123456789&lt;style type=\"text/css\"&gt; div&#123; background-color: #f00; width:-webkit-fit-content; &#125;&lt;/style&gt;&lt;div&gt; 师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt; 本来作为块元素的div会继承父级的宽度，然而加fit-content宽度就会缩小到内容宽度,水平居中margin:auto max-content max-conten表示用内部元素宽度值最大的那个元素的宽度作为最终容器的宽度。简单了说就是文字不换行。咱们去吃个栗子就ok了 1234567891011&lt;style type=\"text/css\"&gt; .box&#123; width:-webkit-max-content; &#125; .son&#123; background: #ff0; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt; min-content min-content表示用内部元素最小宽度值最大的那个元素的宽度作为最终容器的宽度。这个最小宽度值有最大什么意思，如果是图片的话最小宽度值就是图片所呈现的宽度，如果是汉字就是一个字的宽度，如果是英文就是单词的宽度，ok了。 123456789101112131415&lt;style&gt; .box&#123; width:-webkit-min-content; border:1px solid pink; &#125; .brother&#123; width: 120px; height: 20px; background: #f00; &#125;&lt;/style&gt;&lt;div class=\"box\"&gt; &lt;div class=\"brother\"&gt;&lt;/div&gt; &lt;div class=\"son\"&gt;师者，所以传道受业解惑也。人非生而知之者，孰能无惑？惑而不从师，其为惑也，终不解矣。&lt;/div&gt;&lt;/div&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://zhaokunming.xyz/tags/css3/"},{"name":"自适应","slug":"自适应","permalink":"http://zhaokunming.xyz/tags/%E8%87%AA%E9%80%82%E5%BA%94/"}]},{"title":"使用Promise封装简单Ajax方法","date":"2017-12-26T10:47:31.000Z","path":"2017/12/26/使用Promise封装简单Ajax方法/","text":"使用Promise封装简单Ajax方法 在JavaScript的世界中，所有代码都是单线程执行的。 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现： 123456function callback() &#123; console.log('Done');&#125;console.log('before setTimeout()');setTimeout(callback, 1000); // 1秒钟后调用callback函数console.log('after setTimeout()'); 观察上述代码执行，在Chrome的控制台输出可以看到： 1234before setTimeout()after setTimeout()(等待1秒后)Done 可见，异步操作会在将来的某个时间点触发一个函数调用。 AJAX就是典型的异步操作。 GET 1234567891011121314151617181920function getJSON (url) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125; POST 1234567891011121314151617181920function postJSON(url, data) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open(\"POST\", url, true) xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125; 其实Promise就是一个天然的try…catch 1234567getJSON('/api/v1/xxx') // =&gt; 这里面是就try.catch( error =&gt; &#123; // dosomething // =&gt; 这里就是catch到了error，如果处理error以及返还合适的值&#125;).then( value =&gt; &#123; // dosomething // 这里就是final&#125;) 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"ajax","slug":"ajax","permalink":"http://zhaokunming.xyz/tags/ajax/"}]},{"title":"cssText的用法","date":"2017-11-08T04:26:26.000Z","path":"2017/11/08/cssText的用法/","text":"cssText的用法以及特点 cssText 本质是什么？ cssText 的本质就是设置 HTML 元素的 style 属性值。 cssText 怎么用？ 1document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\"; cssText 返回值是什么？ 在某些浏览器中（比如 Chrome），你给他赋什么值，它就返回什么值。在 IE 中则比较痛苦，它会格式化输出、会把属性大写、会改变属性顺序、会去掉最后一个分号，比如： 123document.getElementById(\"d1\").style.cssText = \"color:red; font-size:13px;\";alert(document.getElementById(\"d1\").style.cssText); 在 IE 中值为：FONT-SIZE: 13px; COLOR: red cssText的使用优势 一般情况下我们用js设置元素对象的样式会使用这样的形式： 1234var element= document.getElementById(\"id\"); element.style.width=\"20px\"; element.style.height=\"20px\"; element.style.border=\"solid 1px red\"; 样式一多，代码就很多；而且通过JS来覆写对象的样式是比较典型的一种销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。 js中有一个cssText的方法： 语法为： 123obj.style.cssText=\"样式\";element.style.cssText=\"width:20px;height:20px;border:solid 1px red;\"; 这样就可以尽量避免页面reflow，提高页面性能。 但是，这样会有一个问题，会把原有的cssText清掉，比如原来的style中有’display:none;’，那么执行完上面的JS后，display就被删掉了。 为了解决这个问题，可以采用cssText累加的方法： 1Element.style.cssText += \"width:100px;height:100px;top:100px;left:100px;\" 因此，上面cssText累加的方法在IE中是无效的。 最后，可以在前面添加一个分号来解决这个问题： 1Element.style.cssText += \";width:100px;height:100px;top:100px;left:100px;\" 再进一步，如果前面有样式表文件写着 1div &#123; text-decoration:underline; &#125; 这个会被覆盖吗？不会！因为它不是直接作用于 HTML 元素的 style 属性。 具体案例分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;控制div属性&lt;/title&gt;&lt;style&gt;#outer&#123;width:500px;margin:0 auto;padding:0;text-align:center;&#125;#div1&#123;width:100px;height:100px;background:black;margin:10px auto;display:block;&#125;&lt;/style&gt;&lt;script&gt;var changeStyle = function (elem, attr, value)&#123; elem.style[attr] = value&#125;;window.onload = function ()&#123; var oBtn = document.getElementsByTagName(\"input\"); var oDiv = document.getElementById(\"div1\"); var oAtt = [\"width\",\"height\",\"background\",\"display\",\"display\"]; var oVal = [\"200px\",\"200px\",\"red\",\"none\",\"block\"]; for (var i = 0; i &lt; oBtn.length; i++) &#123; oBtn[i].index = i; oBtn[i].onclick = function () &#123; this.index == oBtn.length - 1 &amp;&amp; (oDiv.style.cssText = \"\"); changeStyle(oDiv, oAtt[this.index], oVal[this.index]) &#125; &#125;&#125;;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"outer\"&gt;&lt;input type=\"button\" value=\"变宽\" /&gt;&lt;input type=\"button\" value=\"变高\" /&gt;&lt;input type=\"button\" value=\"变色\" /&gt;&lt;input type=\"button\" value=\"隐藏\" /&gt;&lt;input type=\"button\" value=\"重置\" /&gt;&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"html","slug":"html","permalink":"http://zhaokunming.xyz/tags/html/"},{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"css","slug":"css","permalink":"http://zhaokunming.xyz/tags/css/"}]},{"title":"vuex的语法糖","date":"2017-09-30T02:18:56.000Z","path":"2017/09/30/vuex的语法糖/","text":"vuex的语法糖-辅助函数mapState , mapMutations , mapActions , mapGetters vuex五大核心 State Getters Mutations Actions Module 我们项目中需要的都是：state、getters、mutations、actions里面的东西调用方法和使用的位置也是有区别的不过vuex给我们提供了辅助函数：mapState , mapMutations , mapActions , mapGetters 调用 方法 辅助函数 state this.$store.state.xxx mapState getters this.$store.getters.xxx mapGetters mutations this.$store.commit(xxx) mapMutations actions this.$store.dispatch(xxx) mapActions 注意mapState和mapGetter的使用只能在computed计算属性中，mapMutations和mapActions使用的时候只能在methods中调用否则报错 如何实际使用辅助函数？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script&gt;import &#123; mapState , mapMutations , mapActions , mapGetters &#125; from 'vuex';export default &#123; data()&#123; return&#123; &#125; &#125;, computed:&#123; ...mapState(&#123; counts:(state) =&gt; state.count &#125;), //mapState就等于下面这个 // counts()&#123; // return this.$store.state.count // &#125;, ...mapGetters(&#123; getternum:'doneTodos' &#125;), //mapGetters就等于下面的这个 // getternum()&#123; // return this.$store.getters.doneTodos // &#125; &#125;, methods:&#123; ...mapMutations(&#123; addnum:'addNum' &#125;), addnum1()&#123; this.addnum() &#125;, //mapMutations就等于下面的这个 // addnum1()&#123; // this.$store.commit('addNum') // &#125;, ...mapActions(&#123; actionnum:'actionNumAdd' &#125;), actionnum6()&#123; this.actionnum() &#125;, //mapActions就等于下面的这个 // actionnum6()&#123; // this.$store.dispatch('actionNumAdd') // &#125; &#125;&#125;&lt;/script&gt; 辅助函数总结 当项目场景中我们需要大量的调用state中的值和触发多个actions的时候，我们还得写大量重复的代码，这时候辅助函数的作用就体现出来了，其实就是vuex的一个语法糖，使代码更简洁更优雅。","tags":[{"name":"vue","slug":"vue","permalink":"http://zhaokunming.xyz/tags/vue/"},{"name":"vuex语法糖","slug":"vuex语法糖","permalink":"http://zhaokunming.xyz/tags/vuex%E8%AF%AD%E6%B3%95%E7%B3%96/"},{"name":"vue辅助函数","slug":"vue辅助函数","permalink":"http://zhaokunming.xyz/tags/vue%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"}]},{"title":"图片懒加载","date":"2017-08-11T01:12:46.000Z","path":"2017/08/11/图片懒加载/","text":"前端实现图片懒加载（lazyload）的两种方式 在实际的项目开发中，我们通常会遇见这样的场景：一个页面有很多图片，而首屏出现的图片大概就一两张，那么我们还要一次性把所有图片都加载出来吗？显然这是愚蠢的，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，技术上现实其中要用的技术就是图片懒加载–到可视区域再加载。 思路： 将页面里所有img属性src属性用data-xx代替，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。也就是说，我们在开始先加载一张图片，这张图片作为所有img的初始src属性，加载一张图片的速度肯定会比加载十张图片的速度快，当我们需要看到img真正要展示的效果时，即出现在用户的可视区域内时，我们在即将进入用户可视区域的时候将img的src属性替换为真实路径，从而实现懒加载。 这就需要监听scroll属性了 关于各种宽高： 12345678910111213页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 示例：jqueryLazyload方式 下载地址：https://github.com/helijun/helijun/blob/master/plugin/lazyLoad/jquery.lazyload.js 123&lt;section class=\"module-section\" id=\"container\"&gt; &lt;img class=\"lazy-load\" data-original=\"../static/img/loveLetter/teacher/teacher1.jpg\" width=\"640\" height=\"480\" alt=\"测试懒加载图片\"/&gt;&lt;/section&gt; 12345678910111213require.config(&#123; baseUrl : \"/static\", paths: &#123; jquery:'component/jquery/jquery-3.1.0.min' jqueryLazyload: 'component/lazyLoad/jquery.lazyload',//图片懒加载 &#125;, shim: &#123; jqueryLazyload: &#123; deps: ['jquery'], exports: '$' &#125; &#125;&#125;); 12345678910111213141516require( [ 'jquery', 'jqueryLazyload' ], function($)&#123; $(document).ready(function() &#123; $(\"img.lazy-load\").lazyload(&#123; effect : \"fadeIn\", //渐现，show(直接显示),fadeIn(淡入),slideDown(下拉) threshold : 180, //预加载，在图片距离屏幕180px时提前载入 event: 'click', // 事件触发时才加载，click(点击),mouseover(鼠标划过),sporty(运动的),默认为scroll（滑动） container: $(\"#container\"), // 指定对某容器中的图片实现效果 failure_limit：2 //加载2张可见区域外的图片,lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况 &#125;); &#125;); &#125;); 为了代码可读性，属性值我都写好了注释。值得注意的是预制图片属性为data-original，并且最好是给予初始高宽占位，以免影响布局，当然这里为了演示我是写死的640x480，如果是响应式页面，高宽需要动态计算。 或者使用纯jquery 123456&lt;style&gt; img&#123; width: 300px; height: 300px; &#125;&lt;/style&gt;//这里给所有图片一个固定大小，为了美观 12345678910&lt;body&gt; &lt;ul&gt;//这里给几张图片简单模拟效果 &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060304326.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\201307060308503.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602395423.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070602573572.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603021166.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"./img/sky.jpg\" data=\"img\\2013070603062432.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829&lt;script&gt; let imgs=document.querySelectorAll('img') loadImg(imgs) window.onscroll=function()&#123; loadImg(imgs) &#125; function loadImg(arr)&#123; for(let i=0;i&lt;arr.length;i++)&#123; if(arr[i].getBoundingClientRect().top &lt; document.documentElement.clientHeight &amp;&amp; !arr[i].isLoad)&#123; arr[i].isLoad = true; // arr[i].style.cssText=\"opacity:0.3\" setTimeout(function()&#123; arr[i].style.cssText='opacity:1;transition:3s;' &#125;,500) aftImg(arr[i],arr[i].getAttribute('data')) &#125; &#125; &#125; function aftImg(obj,url)&#123; var Img=new Image() Img.onload=function()&#123; obj.src=Img.src &#125; Img.src=url; &#125;&lt;/script&gt; echo.js方式 介绍了一款非常简单实用轻量级的图片延时加载插件echo.js，如果你的项目中没有依赖jquery，那么这将是个不错的选择，50行代码，压缩后才1k。当然你完全可以集成到自己项目中去！ 下载地址：https://github.com/helijun/helijun/tree/master/plugin/echo 123456&lt;style&gt; .demo img &#123; width: 736px; height: 490px; background: url(images/loading.gif) 50% no-repeat;&#125;&lt;/style&gt; 123&lt;div class=\"demo\"&gt; &lt;img class=\"lazy\" src=\"images/blank.gif\" data-echo=\"images/big-1.jpg\"&gt;&lt;/div&gt; 12345678910&lt;script src=\"js/echo.min.js\"&gt;&lt;/script&gt;&lt;script&gt;Echo.init(&#123; offset: 0,//离可视区域多少像素的图片可以被加载 throttle: 0 //图片延时多少毫秒加载&#125;); &lt;/script&gt; 说明：blank.gif是一张背景图片，包含在插件里了。图片的宽高必须设定，当然，可以使用外部样式对多张图片统一控制大小。data-echo指向的是真正的图片地址。","tags":[{"name":"js","slug":"js","permalink":"http://zhaokunming.xyz/tags/js/"},{"name":"前端","slug":"前端","permalink":"http://zhaokunming.xyz/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"总要写点什么","date":"2017-07-14T01:25:57.000Z","path":"2017/07/14/start/","text":"本博开博文章，以祭奠流逝的时间 今天是个好日子，在经历了无数的挫折之后，我终于也是拥有了一个自己的博客网站。 仿佛每个人都要写一下开博文章，我也就写一下吧，一方面是为了记录我搭建博客的心酸，另一方面也回忆一下过去，展望一下未来。 怎么萌生一个搭建个人博客的念头的呢？这个没有确切的起点，起初我的笔记，工作经验什么的都写在了印象笔记里面，也就是记录一下生活，工作的问题，但大多只是记录，没有太多的思考。而管理个人博客就要花更多的时间去管理、维护，更多的这是属于自己的小空间。同时，我看到网站上的博客越来越多，而且也很方便，可以和更多的技术大牛沟通，交流技术。这样看来，搭建个人博客还是很有必要的（我是这样说服自己的）。 搭建之路很漫长，本来可以一两天搞定的事情，我花了一个多星期。原因，主要是我的环境坏掉了。好像hexo都有一个弊端吧，就是init只能一个，再多就会报错。不可修复的那种，最重要的是不要把第一次init的文件删了。我就是死在的这一步。当时请教了一些人，没有解决，还衍生出了其他的错误。环境坏了能怎么办，心灰意冷只能换电脑。不过好在成功搭建，于是才有了它。这还是一个看脸的时代，好的皮肤可能比操作还要重要，所以，又花费时间找了个还不错的主题。这里问题就不再详述了。总之，它就这样走进我的生活当中。过程很残忍，却被成功的喜悦覆盖了。 现在看来，搭建博客很简单吗，，，对。不过，有句话说，坚持难，例子，就是苏格拉底的例子。要持续更新博客，这可是个技术活。思考，这是必不可少的，同时，博客可能不止自己看，所以，应该让大多数的人看懂，这很重要。多长时间更一篇，这个，还没想好，不过，要有时间，要坚持，坚持就是胜利。 这里引进胡伟煌的一段话：“花费了这么多时间和精力，对我个人来说是否有什么影响，应该是说找到了一种比较笨的学习方式。写博客是很耗时间的，需要将你学习到的东西通过自己认为比较简练的语言归纳整理，并且有条理或系统地去让别人更容易读懂，在这过程中自己的总结归纳能力等可以得到锻炼，而有的知识你以为懂了，当要写出来的时候会发现好像还没懂，这时候也可以再去思考这个知识。当形成了自己的知识体系后，即时你哪天忘记了你写的内容，也可以很快的找到答案所在的地方。就好比开卷考试，当你记不住答案或者也不一定要记住答案是什么，只需要知道在哪里可以快速找到答案就够了。如果可以快速有效地解决问题，也不一定要关心你是怎么解决的。当你学的东西越来越多，你会发现你不懂的也越来越多，好比一个圆，圆内的面积越大，圆外接触的不懂的东西也越多。” 第一：生活 搭建博客的初衷，是沉淀一些自己知识、技能的记录。我对技术非常好奇，不断去尝试，各种摸索、各种分析。生活不仅仅只是上班下班，在上班的过程里面，还有那么一些尝试，让我尝试完，积累知识，然后好好沉淀下。 我一直都是一个很懂得“接受”的人，为什么说是接受呢？因为我觉得，我在生活中经历过的大大小小的各种事情，都是对自己的考验，按照市面上的一句话来说，就是感恩苦难。当然苦难本身是不值得感恩的，胡歌在采访中说，苦难本身是不值得感恩的，苦难带来的伤痛是无法抹去的。我真正要感谢的是自己在经历了各种事情之后所积累的经验与能力。所以说，我在碰到困难的时候第一想的不是放弃，而是尝试解决，就比如我在编程过程中，解决问题的最好方法是解决问题本身，而不是换条路达到解决问题的目的。当然，二者兼得更好。 或者现实一点的说法就是，我在不断增强自己的实力。活到老，学到老。我希望我的一生能够贯彻这一点。 第二：未来 毕业有一段时间了，工作暂时找好了，工作失误免不了被老板骂，一直没有离职。一方面，确实是自己做错了，无可厚非，错了就是错了，我也在积累项目错误的经验，为了以后再次碰到这种情况能快速解决。一方面，我觉得没必要记恨别人，人的一生也不过是白驹过隙，能让人生更有意义一些才会在闭上眼睛回望一生时嘴角上扬。而且，老板也不坏，人之初，性本善，当然也可能是我还没碰到所以才说出这样的话。这里，我要感谢我老板在我工作方面的照顾，批评我的错误是正常的，体谅员工的老板才是好老板，巧的是，我的老板就是这样的人。 对未来的规划，小时候，在电视上看职场情景，有赶地铁的人，拿着早餐路上吃的上班族，早上赶电梯，晚上外套一脱，躺床上。好像生活很单一，又很无聊。如今看来，似乎生活还有很多乐趣。工作也不是如僵尸一样低头看文档。现在，首先是挣钱吧，最主要的是养活自己，不至于看到有人帮助的时候一掏腰包两手空，然后努力工作，给父母更好的生活，闲暇时间还可以旅旅游，放松一下。然后感叹，这就是生活鸭。 未来可期！ 第三：时间 时间是个好东西，只喜多不喜少。 就比如，这篇博客吧，本来打算二十分钟写完的，结果，边想边写，就花费了四十多分钟。 最近遇到一些事情，逼迫自己去思考工作、生活的意义。才发现工作是忙了，但是得到的除了钱，好像什么都没有。 精神还是空虚着，能力还是没怎么提高，未来10年、20年，靠什么继续下去？ 开一个博客，对人生的一种坚持与新生，在未来，尝试不一样的事情，对生活，充满着期待！","tags":[{"name":"生活","slug":"生活","permalink":"http://zhaokunming.xyz/tags/%E7%94%9F%E6%B4%BB/"},{"name":"start","slug":"start","permalink":"http://zhaokunming.xyz/tags/start/"}]}]